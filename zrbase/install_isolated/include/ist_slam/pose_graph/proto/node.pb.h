// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ist_slam/pose_graph/proto/node.proto

#ifndef PROTOBUF_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto__INCLUDED
#define PROTOBUF_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ist_slam/transform/proto/transform.pb.h"
// @@protoc_insertion_point(includes)
namespace ist_slam {
namespace pose_graph {
namespace proto {
class ImuCalibration;
class ImuCalibrationDefaultTypeInternal;
extern ImuCalibrationDefaultTypeInternal _ImuCalibration_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeId;
class NodeIdDefaultTypeInternal;
extern NodeIdDefaultTypeInternal _NodeId_default_instance_;
class Parameters;
class ParametersDefaultTypeInternal;
extern ParametersDefaultTypeInternal _Parameters_default_instance_;
class Pose2D;
class Pose2DDefaultTypeInternal;
extern Pose2DDefaultTypeInternal _Pose2D_default_instance_;
class Pose3D;
class Pose3DDefaultTypeInternal;
extern Pose3DDefaultTypeInternal _Pose3D_default_instance_;
}  // namespace proto
}  // namespace pose_graph
}  // namespace ist_slam

namespace ist_slam {
namespace pose_graph {
namespace proto {

namespace protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto

enum Parameterization {
  NONE = 0,
  FIX_Z = 1,
  YAW_ONLY = 2,
  YAW_CONSTANT = 3,
  Parameterization_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Parameterization_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Parameterization_IsValid(int value);
const Parameterization Parameterization_MIN = NONE;
const Parameterization Parameterization_MAX = YAW_CONSTANT;
const int Parameterization_ARRAYSIZE = Parameterization_MAX + 1;

const ::google::protobuf::EnumDescriptor* Parameterization_descriptor();
inline const ::std::string& Parameterization_Name(Parameterization value) {
  return ::google::protobuf::internal::NameOfEnum(
    Parameterization_descriptor(), value);
}
inline bool Parameterization_Parse(
    const ::std::string& name, Parameterization* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Parameterization>(
    Parameterization_descriptor(), name, value);
}
// ===================================================================

class Pose2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.pose_graph.proto.Pose2D) */ {
 public:
  Pose2D();
  virtual ~Pose2D();

  Pose2D(const Pose2D& from);

  inline Pose2D& operator=(const Pose2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose2D(Pose2D&& from) noexcept
    : Pose2D() {
    *this = ::std::move(from);
  }

  inline Pose2D& operator=(Pose2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose2D& default_instance();

  static inline const Pose2D* internal_default_instance() {
    return reinterpret_cast<const Pose2D*>(
               &_Pose2D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Pose2D* other);
  friend void swap(Pose2D& a, Pose2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose2D* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose2D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose2D& from);
  void MergeFrom(const Pose2D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.transform.proto.Vector2d translation = 1;
  bool has_translation() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 1;
  const ::ist_slam::transform::proto::Vector2d& translation() const;
  ::ist_slam::transform::proto::Vector2d* mutable_translation();
  ::ist_slam::transform::proto::Vector2d* release_translation();
  void set_allocated_translation(::ist_slam::transform::proto::Vector2d* translation);

  // double rotation = 2;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  double rotation() const;
  void set_rotation(double value);

  // @@protoc_insertion_point(class_scope:ist_slam.pose_graph.proto.Pose2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::transform::proto::Vector2d* translation_;
  double rotation_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose3D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.pose_graph.proto.Pose3D) */ {
 public:
  Pose3D();
  virtual ~Pose3D();

  Pose3D(const Pose3D& from);

  inline Pose3D& operator=(const Pose3D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose3D(Pose3D&& from) noexcept
    : Pose3D() {
    *this = ::std::move(from);
  }

  inline Pose3D& operator=(Pose3D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose3D& default_instance();

  static inline const Pose3D* internal_default_instance() {
    return reinterpret_cast<const Pose3D*>(
               &_Pose3D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Pose3D* other);
  friend void swap(Pose3D& a, Pose3D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose3D* New() const PROTOBUF_FINAL { return New(NULL); }

  Pose3D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pose3D& from);
  void MergeFrom(const Pose3D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pose3D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.transform.proto.Vector3d translation = 1;
  bool has_translation() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 1;
  const ::ist_slam::transform::proto::Vector3d& translation() const;
  ::ist_slam::transform::proto::Vector3d* mutable_translation();
  ::ist_slam::transform::proto::Vector3d* release_translation();
  void set_allocated_translation(::ist_slam::transform::proto::Vector3d* translation);

  // .ist_slam.transform.proto.Quaterniond rotation = 2;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 2;
  const ::ist_slam::transform::proto::Quaterniond& rotation() const;
  ::ist_slam::transform::proto::Quaterniond* mutable_rotation();
  ::ist_slam::transform::proto::Quaterniond* release_rotation();
  void set_allocated_rotation(::ist_slam::transform::proto::Quaterniond* rotation);

  // .ist_slam.pose_graph.proto.Parameterization translation_parameterization = 3;
  void clear_translation_parameterization();
  static const int kTranslationParameterizationFieldNumber = 3;
  ::ist_slam::pose_graph::proto::Parameterization translation_parameterization() const;
  void set_translation_parameterization(::ist_slam::pose_graph::proto::Parameterization value);

  // .ist_slam.pose_graph.proto.Parameterization rotation_parameterization = 4;
  void clear_rotation_parameterization();
  static const int kRotationParameterizationFieldNumber = 4;
  ::ist_slam::pose_graph::proto::Parameterization rotation_parameterization() const;
  void set_rotation_parameterization(::ist_slam::pose_graph::proto::Parameterization value);

  // @@protoc_insertion_point(class_scope:ist_slam.pose_graph.proto.Pose3D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::transform::proto::Vector3d* translation_;
  ::ist_slam::transform::proto::Quaterniond* rotation_;
  int translation_parameterization_;
  int rotation_parameterization_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImuCalibration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.pose_graph.proto.ImuCalibration) */ {
 public:
  ImuCalibration();
  virtual ~ImuCalibration();

  ImuCalibration(const ImuCalibration& from);

  inline ImuCalibration& operator=(const ImuCalibration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImuCalibration(ImuCalibration&& from) noexcept
    : ImuCalibration() {
    *this = ::std::move(from);
  }

  inline ImuCalibration& operator=(ImuCalibration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImuCalibration& default_instance();

  static inline const ImuCalibration* internal_default_instance() {
    return reinterpret_cast<const ImuCalibration*>(
               &_ImuCalibration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ImuCalibration* other);
  friend void swap(ImuCalibration& a, ImuCalibration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImuCalibration* New() const PROTOBUF_FINAL { return New(NULL); }

  ImuCalibration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImuCalibration& from);
  void MergeFrom(const ImuCalibration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImuCalibration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.transform.proto.Quaterniond orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  const ::ist_slam::transform::proto::Quaterniond& orientation() const;
  ::ist_slam::transform::proto::Quaterniond* mutable_orientation();
  ::ist_slam::transform::proto::Quaterniond* release_orientation();
  void set_allocated_orientation(::ist_slam::transform::proto::Quaterniond* orientation);

  // double gravity_constant = 1;
  void clear_gravity_constant();
  static const int kGravityConstantFieldNumber = 1;
  double gravity_constant() const;
  void set_gravity_constant(double value);

  // .ist_slam.pose_graph.proto.Parameterization orientation_parameterization = 3;
  void clear_orientation_parameterization();
  static const int kOrientationParameterizationFieldNumber = 3;
  ::ist_slam::pose_graph::proto::Parameterization orientation_parameterization() const;
  void set_orientation_parameterization(::ist_slam::pose_graph::proto::Parameterization value);

  // @@protoc_insertion_point(class_scope:ist_slam.pose_graph.proto.ImuCalibration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::transform::proto::Quaterniond* orientation_;
  double gravity_constant_;
  int orientation_parameterization_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.pose_graph.proto.NodeId) */ {
 public:
  NodeId();
  virtual ~NodeId();

  NodeId(const NodeId& from);

  inline NodeId& operator=(const NodeId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeId(NodeId&& from) noexcept
    : NodeId() {
    *this = ::std::move(from);
  }

  inline NodeId& operator=(NodeId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeId& default_instance();

  static inline const NodeId* internal_default_instance() {
    return reinterpret_cast<const NodeId*>(
               &_NodeId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NodeId* other);
  friend void swap(NodeId& a, NodeId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeId* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeId& from);
  void MergeFrom(const NodeId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string object_id = 1;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  const ::std::string& object_id() const;
  void set_object_id(const ::std::string& value);
  #if LANG_CXX11
  void set_object_id(::std::string&& value);
  #endif
  void set_object_id(const char* value);
  void set_object_id(const char* value, size_t size);
  ::std::string* mutable_object_id();
  ::std::string* release_object_id();
  void set_allocated_object_id(::std::string* object_id);

  // string group_id = 2;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  const ::std::string& group_id() const;
  void set_group_id(const ::std::string& value);
  #if LANG_CXX11
  void set_group_id(::std::string&& value);
  #endif
  void set_group_id(const char* value);
  void set_group_id(const char* value, size_t size);
  ::std::string* mutable_group_id();
  ::std::string* release_group_id();
  void set_allocated_group_id(::std::string* group_id);

  // int64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ist_slam.pose_graph.proto.NodeId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr object_id_;
  ::google::protobuf::internal::ArenaStringPtr group_id_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Parameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.pose_graph.proto.Parameters) */ {
 public:
  Parameters();
  virtual ~Parameters();

  Parameters(const Parameters& from);

  inline Parameters& operator=(const Parameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parameters(Parameters&& from) noexcept
    : Parameters() {
    *this = ::std::move(from);
  }

  inline Parameters& operator=(Parameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameters& default_instance();

  enum TypeCase {
    kPose2D = 1,
    kPose3D = 2,
    kImuCalibration = 3,
    TYPE_NOT_SET = 0,
  };

  static inline const Parameters* internal_default_instance() {
    return reinterpret_cast<const Parameters*>(
               &_Parameters_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Parameters* other);
  friend void swap(Parameters& a, Parameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parameters* New() const PROTOBUF_FINAL { return New(NULL); }

  Parameters* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Parameters& from);
  void MergeFrom(const Parameters& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Parameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.pose_graph.proto.Pose2D pose_2d = 1;
  bool has_pose_2d() const;
  void clear_pose_2d();
  static const int kPose2DFieldNumber = 1;
  const ::ist_slam::pose_graph::proto::Pose2D& pose_2d() const;
  ::ist_slam::pose_graph::proto::Pose2D* mutable_pose_2d();
  ::ist_slam::pose_graph::proto::Pose2D* release_pose_2d();
  void set_allocated_pose_2d(::ist_slam::pose_graph::proto::Pose2D* pose_2d);

  // .ist_slam.pose_graph.proto.Pose3D pose_3d = 2;
  bool has_pose_3d() const;
  void clear_pose_3d();
  static const int kPose3DFieldNumber = 2;
  const ::ist_slam::pose_graph::proto::Pose3D& pose_3d() const;
  ::ist_slam::pose_graph::proto::Pose3D* mutable_pose_3d();
  ::ist_slam::pose_graph::proto::Pose3D* release_pose_3d();
  void set_allocated_pose_3d(::ist_slam::pose_graph::proto::Pose3D* pose_3d);

  // .ist_slam.pose_graph.proto.ImuCalibration imu_calibration = 3;
  bool has_imu_calibration() const;
  void clear_imu_calibration();
  static const int kImuCalibrationFieldNumber = 3;
  const ::ist_slam::pose_graph::proto::ImuCalibration& imu_calibration() const;
  ::ist_slam::pose_graph::proto::ImuCalibration* mutable_imu_calibration();
  ::ist_slam::pose_graph::proto::ImuCalibration* release_imu_calibration();
  void set_allocated_imu_calibration(::ist_slam::pose_graph::proto::ImuCalibration* imu_calibration);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:ist_slam.pose_graph.proto.Parameters)
 private:
  void set_has_pose_2d();
  void set_has_pose_3d();
  void set_has_imu_calibration();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::ist_slam::pose_graph::proto::Pose2D* pose_2d_;
    ::ist_slam::pose_graph::proto::Pose3D* pose_3d_;
    ::ist_slam::pose_graph::proto::ImuCalibration* imu_calibration_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.pose_graph.proto.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const PROTOBUF_FINAL { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.pose_graph.proto.NodeId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::ist_slam::pose_graph::proto::NodeId& id() const;
  ::ist_slam::pose_graph::proto::NodeId* mutable_id();
  ::ist_slam::pose_graph::proto::NodeId* release_id();
  void set_allocated_id(::ist_slam::pose_graph::proto::NodeId* id);

  // .ist_slam.pose_graph.proto.Parameters parameters = 3;
  bool has_parameters() const;
  void clear_parameters();
  static const int kParametersFieldNumber = 3;
  const ::ist_slam::pose_graph::proto::Parameters& parameters() const;
  ::ist_slam::pose_graph::proto::Parameters* mutable_parameters();
  ::ist_slam::pose_graph::proto::Parameters* release_parameters();
  void set_allocated_parameters(::ist_slam::pose_graph::proto::Parameters* parameters);

  // bool constant = 2;
  void clear_constant();
  static const int kConstantFieldNumber = 2;
  bool constant() const;
  void set_constant(bool value);

  // @@protoc_insertion_point(class_scope:ist_slam.pose_graph.proto.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::pose_graph::proto::NodeId* id_;
  ::ist_slam::pose_graph::proto::Parameters* parameters_;
  bool constant_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Pose2D

// .ist_slam.transform.proto.Vector2d translation = 1;
inline bool Pose2D::has_translation() const {
  return this != internal_default_instance() && translation_ != NULL;
}
inline void Pose2D::clear_translation() {
  if (GetArenaNoVirtual() == NULL && translation_ != NULL) delete translation_;
  translation_ = NULL;
}
inline const ::ist_slam::transform::proto::Vector2d& Pose2D::translation() const {
  const ::ist_slam::transform::proto::Vector2d* p = translation_;
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Pose2D.translation)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Vector2d*>(
      &::ist_slam::transform::proto::_Vector2d_default_instance_);
}
inline ::ist_slam::transform::proto::Vector2d* Pose2D::mutable_translation() {
  
  if (translation_ == NULL) {
    translation_ = new ::ist_slam::transform::proto::Vector2d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Pose2D.translation)
  return translation_;
}
inline ::ist_slam::transform::proto::Vector2d* Pose2D::release_translation() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Pose2D.translation)
  
  ::ist_slam::transform::proto::Vector2d* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Pose2D::set_allocated_translation(::ist_slam::transform::proto::Vector2d* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Pose2D.translation)
}

// double rotation = 2;
inline void Pose2D::clear_rotation() {
  rotation_ = 0;
}
inline double Pose2D::rotation() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Pose2D.rotation)
  return rotation_;
}
inline void Pose2D::set_rotation(double value) {
  
  rotation_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.Pose2D.rotation)
}

// -------------------------------------------------------------------

// Pose3D

// .ist_slam.transform.proto.Vector3d translation = 1;
inline bool Pose3D::has_translation() const {
  return this != internal_default_instance() && translation_ != NULL;
}
inline void Pose3D::clear_translation() {
  if (GetArenaNoVirtual() == NULL && translation_ != NULL) delete translation_;
  translation_ = NULL;
}
inline const ::ist_slam::transform::proto::Vector3d& Pose3D::translation() const {
  const ::ist_slam::transform::proto::Vector3d* p = translation_;
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Pose3D.translation)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Vector3d*>(
      &::ist_slam::transform::proto::_Vector3d_default_instance_);
}
inline ::ist_slam::transform::proto::Vector3d* Pose3D::mutable_translation() {
  
  if (translation_ == NULL) {
    translation_ = new ::ist_slam::transform::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Pose3D.translation)
  return translation_;
}
inline ::ist_slam::transform::proto::Vector3d* Pose3D::release_translation() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Pose3D.translation)
  
  ::ist_slam::transform::proto::Vector3d* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Pose3D::set_allocated_translation(::ist_slam::transform::proto::Vector3d* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Pose3D.translation)
}

// .ist_slam.transform.proto.Quaterniond rotation = 2;
inline bool Pose3D::has_rotation() const {
  return this != internal_default_instance() && rotation_ != NULL;
}
inline void Pose3D::clear_rotation() {
  if (GetArenaNoVirtual() == NULL && rotation_ != NULL) delete rotation_;
  rotation_ = NULL;
}
inline const ::ist_slam::transform::proto::Quaterniond& Pose3D::rotation() const {
  const ::ist_slam::transform::proto::Quaterniond* p = rotation_;
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Pose3D.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Quaterniond*>(
      &::ist_slam::transform::proto::_Quaterniond_default_instance_);
}
inline ::ist_slam::transform::proto::Quaterniond* Pose3D::mutable_rotation() {
  
  if (rotation_ == NULL) {
    rotation_ = new ::ist_slam::transform::proto::Quaterniond;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Pose3D.rotation)
  return rotation_;
}
inline ::ist_slam::transform::proto::Quaterniond* Pose3D::release_rotation() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Pose3D.rotation)
  
  ::ist_slam::transform::proto::Quaterniond* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void Pose3D::set_allocated_rotation(::ist_slam::transform::proto::Quaterniond* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Pose3D.rotation)
}

// .ist_slam.pose_graph.proto.Parameterization translation_parameterization = 3;
inline void Pose3D::clear_translation_parameterization() {
  translation_parameterization_ = 0;
}
inline ::ist_slam::pose_graph::proto::Parameterization Pose3D::translation_parameterization() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Pose3D.translation_parameterization)
  return static_cast< ::ist_slam::pose_graph::proto::Parameterization >(translation_parameterization_);
}
inline void Pose3D::set_translation_parameterization(::ist_slam::pose_graph::proto::Parameterization value) {
  
  translation_parameterization_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.Pose3D.translation_parameterization)
}

// .ist_slam.pose_graph.proto.Parameterization rotation_parameterization = 4;
inline void Pose3D::clear_rotation_parameterization() {
  rotation_parameterization_ = 0;
}
inline ::ist_slam::pose_graph::proto::Parameterization Pose3D::rotation_parameterization() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Pose3D.rotation_parameterization)
  return static_cast< ::ist_slam::pose_graph::proto::Parameterization >(rotation_parameterization_);
}
inline void Pose3D::set_rotation_parameterization(::ist_slam::pose_graph::proto::Parameterization value) {
  
  rotation_parameterization_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.Pose3D.rotation_parameterization)
}

// -------------------------------------------------------------------

// ImuCalibration

// double gravity_constant = 1;
inline void ImuCalibration::clear_gravity_constant() {
  gravity_constant_ = 0;
}
inline double ImuCalibration::gravity_constant() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.ImuCalibration.gravity_constant)
  return gravity_constant_;
}
inline void ImuCalibration::set_gravity_constant(double value) {
  
  gravity_constant_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.ImuCalibration.gravity_constant)
}

// .ist_slam.transform.proto.Quaterniond orientation = 2;
inline bool ImuCalibration::has_orientation() const {
  return this != internal_default_instance() && orientation_ != NULL;
}
inline void ImuCalibration::clear_orientation() {
  if (GetArenaNoVirtual() == NULL && orientation_ != NULL) delete orientation_;
  orientation_ = NULL;
}
inline const ::ist_slam::transform::proto::Quaterniond& ImuCalibration::orientation() const {
  const ::ist_slam::transform::proto::Quaterniond* p = orientation_;
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.ImuCalibration.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Quaterniond*>(
      &::ist_slam::transform::proto::_Quaterniond_default_instance_);
}
inline ::ist_slam::transform::proto::Quaterniond* ImuCalibration::mutable_orientation() {
  
  if (orientation_ == NULL) {
    orientation_ = new ::ist_slam::transform::proto::Quaterniond;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.ImuCalibration.orientation)
  return orientation_;
}
inline ::ist_slam::transform::proto::Quaterniond* ImuCalibration::release_orientation() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.ImuCalibration.orientation)
  
  ::ist_slam::transform::proto::Quaterniond* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void ImuCalibration::set_allocated_orientation(::ist_slam::transform::proto::Quaterniond* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.ImuCalibration.orientation)
}

// .ist_slam.pose_graph.proto.Parameterization orientation_parameterization = 3;
inline void ImuCalibration::clear_orientation_parameterization() {
  orientation_parameterization_ = 0;
}
inline ::ist_slam::pose_graph::proto::Parameterization ImuCalibration::orientation_parameterization() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.ImuCalibration.orientation_parameterization)
  return static_cast< ::ist_slam::pose_graph::proto::Parameterization >(orientation_parameterization_);
}
inline void ImuCalibration::set_orientation_parameterization(::ist_slam::pose_graph::proto::Parameterization value) {
  
  orientation_parameterization_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.ImuCalibration.orientation_parameterization)
}

// -------------------------------------------------------------------

// NodeId

// string object_id = 1;
inline void NodeId::clear_object_id() {
  object_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeId::object_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.NodeId.object_id)
  return object_id_.GetNoArena();
}
inline void NodeId::set_object_id(const ::std::string& value) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.NodeId.object_id)
}
#if LANG_CXX11
inline void NodeId::set_object_id(::std::string&& value) {
  
  object_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.pose_graph.proto.NodeId.object_id)
}
#endif
inline void NodeId::set_object_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.pose_graph.proto.NodeId.object_id)
}
inline void NodeId::set_object_id(const char* value, size_t size) {
  
  object_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.pose_graph.proto.NodeId.object_id)
}
inline ::std::string* NodeId::mutable_object_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.NodeId.object_id)
  return object_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeId::release_object_id() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.NodeId.object_id)
  
  return object_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeId::set_allocated_object_id(::std::string* object_id) {
  if (object_id != NULL) {
    
  } else {
    
  }
  object_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.NodeId.object_id)
}

// string group_id = 2;
inline void NodeId::clear_group_id() {
  group_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeId::group_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.NodeId.group_id)
  return group_id_.GetNoArena();
}
inline void NodeId::set_group_id(const ::std::string& value) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.NodeId.group_id)
}
#if LANG_CXX11
inline void NodeId::set_group_id(::std::string&& value) {
  
  group_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.pose_graph.proto.NodeId.group_id)
}
#endif
inline void NodeId::set_group_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.pose_graph.proto.NodeId.group_id)
}
inline void NodeId::set_group_id(const char* value, size_t size) {
  
  group_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.pose_graph.proto.NodeId.group_id)
}
inline ::std::string* NodeId::mutable_group_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.NodeId.group_id)
  return group_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeId::release_group_id() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.NodeId.group_id)
  
  return group_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeId::set_allocated_group_id(::std::string* group_id) {
  if (group_id != NULL) {
    
  } else {
    
  }
  group_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.NodeId.group_id)
}

// int64 timestamp = 3;
inline void NodeId::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NodeId::timestamp() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.NodeId.timestamp)
  return timestamp_;
}
inline void NodeId::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.NodeId.timestamp)
}

// -------------------------------------------------------------------

// Parameters

// .ist_slam.pose_graph.proto.Pose2D pose_2d = 1;
inline bool Parameters::has_pose_2d() const {
  return type_case() == kPose2D;
}
inline void Parameters::set_has_pose_2d() {
  _oneof_case_[0] = kPose2D;
}
inline void Parameters::clear_pose_2d() {
  if (has_pose_2d()) {
    delete type_.pose_2d_;
    clear_has_type();
  }
}
inline  const ::ist_slam::pose_graph::proto::Pose2D& Parameters::pose_2d() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Parameters.pose_2d)
  return has_pose_2d()
      ? *type_.pose_2d_
      : ::ist_slam::pose_graph::proto::Pose2D::default_instance();
}
inline ::ist_slam::pose_graph::proto::Pose2D* Parameters::mutable_pose_2d() {
  if (!has_pose_2d()) {
    clear_type();
    set_has_pose_2d();
    type_.pose_2d_ = new ::ist_slam::pose_graph::proto::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Parameters.pose_2d)
  return type_.pose_2d_;
}
inline ::ist_slam::pose_graph::proto::Pose2D* Parameters::release_pose_2d() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Parameters.pose_2d)
  if (has_pose_2d()) {
    clear_has_type();
    ::ist_slam::pose_graph::proto::Pose2D* temp = type_.pose_2d_;
    type_.pose_2d_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Parameters::set_allocated_pose_2d(::ist_slam::pose_graph::proto::Pose2D* pose_2d) {
  clear_type();
  if (pose_2d) {
    set_has_pose_2d();
    type_.pose_2d_ = pose_2d;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Parameters.pose_2d)
}

// .ist_slam.pose_graph.proto.Pose3D pose_3d = 2;
inline bool Parameters::has_pose_3d() const {
  return type_case() == kPose3D;
}
inline void Parameters::set_has_pose_3d() {
  _oneof_case_[0] = kPose3D;
}
inline void Parameters::clear_pose_3d() {
  if (has_pose_3d()) {
    delete type_.pose_3d_;
    clear_has_type();
  }
}
inline  const ::ist_slam::pose_graph::proto::Pose3D& Parameters::pose_3d() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Parameters.pose_3d)
  return has_pose_3d()
      ? *type_.pose_3d_
      : ::ist_slam::pose_graph::proto::Pose3D::default_instance();
}
inline ::ist_slam::pose_graph::proto::Pose3D* Parameters::mutable_pose_3d() {
  if (!has_pose_3d()) {
    clear_type();
    set_has_pose_3d();
    type_.pose_3d_ = new ::ist_slam::pose_graph::proto::Pose3D;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Parameters.pose_3d)
  return type_.pose_3d_;
}
inline ::ist_slam::pose_graph::proto::Pose3D* Parameters::release_pose_3d() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Parameters.pose_3d)
  if (has_pose_3d()) {
    clear_has_type();
    ::ist_slam::pose_graph::proto::Pose3D* temp = type_.pose_3d_;
    type_.pose_3d_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Parameters::set_allocated_pose_3d(::ist_slam::pose_graph::proto::Pose3D* pose_3d) {
  clear_type();
  if (pose_3d) {
    set_has_pose_3d();
    type_.pose_3d_ = pose_3d;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Parameters.pose_3d)
}

// .ist_slam.pose_graph.proto.ImuCalibration imu_calibration = 3;
inline bool Parameters::has_imu_calibration() const {
  return type_case() == kImuCalibration;
}
inline void Parameters::set_has_imu_calibration() {
  _oneof_case_[0] = kImuCalibration;
}
inline void Parameters::clear_imu_calibration() {
  if (has_imu_calibration()) {
    delete type_.imu_calibration_;
    clear_has_type();
  }
}
inline  const ::ist_slam::pose_graph::proto::ImuCalibration& Parameters::imu_calibration() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Parameters.imu_calibration)
  return has_imu_calibration()
      ? *type_.imu_calibration_
      : ::ist_slam::pose_graph::proto::ImuCalibration::default_instance();
}
inline ::ist_slam::pose_graph::proto::ImuCalibration* Parameters::mutable_imu_calibration() {
  if (!has_imu_calibration()) {
    clear_type();
    set_has_imu_calibration();
    type_.imu_calibration_ = new ::ist_slam::pose_graph::proto::ImuCalibration;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Parameters.imu_calibration)
  return type_.imu_calibration_;
}
inline ::ist_slam::pose_graph::proto::ImuCalibration* Parameters::release_imu_calibration() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Parameters.imu_calibration)
  if (has_imu_calibration()) {
    clear_has_type();
    ::ist_slam::pose_graph::proto::ImuCalibration* temp = type_.imu_calibration_;
    type_.imu_calibration_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Parameters::set_allocated_imu_calibration(::ist_slam::pose_graph::proto::ImuCalibration* imu_calibration) {
  clear_type();
  if (imu_calibration) {
    set_has_imu_calibration();
    type_.imu_calibration_ = imu_calibration;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Parameters.imu_calibration)
}

inline bool Parameters::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Parameters::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Parameters::TypeCase Parameters::type_case() const {
  return Parameters::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Node

// .ist_slam.pose_graph.proto.NodeId id = 1;
inline bool Node::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline void Node::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::ist_slam::pose_graph::proto::NodeId& Node::id() const {
  const ::ist_slam::pose_graph::proto::NodeId* p = id_;
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Node.id)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::pose_graph::proto::NodeId*>(
      &::ist_slam::pose_graph::proto::_NodeId_default_instance_);
}
inline ::ist_slam::pose_graph::proto::NodeId* Node::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::ist_slam::pose_graph::proto::NodeId;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Node.id)
  return id_;
}
inline ::ist_slam::pose_graph::proto::NodeId* Node::release_id() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Node.id)
  
  ::ist_slam::pose_graph::proto::NodeId* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Node::set_allocated_id(::ist_slam::pose_graph::proto::NodeId* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Node.id)
}

// bool constant = 2;
inline void Node::clear_constant() {
  constant_ = false;
}
inline bool Node::constant() const {
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Node.constant)
  return constant_;
}
inline void Node::set_constant(bool value) {
  
  constant_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.pose_graph.proto.Node.constant)
}

// .ist_slam.pose_graph.proto.Parameters parameters = 3;
inline bool Node::has_parameters() const {
  return this != internal_default_instance() && parameters_ != NULL;
}
inline void Node::clear_parameters() {
  if (GetArenaNoVirtual() == NULL && parameters_ != NULL) delete parameters_;
  parameters_ = NULL;
}
inline const ::ist_slam::pose_graph::proto::Parameters& Node::parameters() const {
  const ::ist_slam::pose_graph::proto::Parameters* p = parameters_;
  // @@protoc_insertion_point(field_get:ist_slam.pose_graph.proto.Node.parameters)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::pose_graph::proto::Parameters*>(
      &::ist_slam::pose_graph::proto::_Parameters_default_instance_);
}
inline ::ist_slam::pose_graph::proto::Parameters* Node::mutable_parameters() {
  
  if (parameters_ == NULL) {
    parameters_ = new ::ist_slam::pose_graph::proto::Parameters;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.pose_graph.proto.Node.parameters)
  return parameters_;
}
inline ::ist_slam::pose_graph::proto::Parameters* Node::release_parameters() {
  // @@protoc_insertion_point(field_release:ist_slam.pose_graph.proto.Node.parameters)
  
  ::ist_slam::pose_graph::proto::Parameters* temp = parameters_;
  parameters_ = NULL;
  return temp;
}
inline void Node::set_allocated_parameters(::ist_slam::pose_graph::proto::Parameters* parameters) {
  delete parameters_;
  parameters_ = parameters;
  if (parameters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.pose_graph.proto.Node.parameters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto
}  // namespace pose_graph
}  // namespace ist_slam

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ist_slam::pose_graph::proto::Parameterization> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ist_slam::pose_graph::proto::Parameterization>() {
  return ::ist_slam::pose_graph::proto::Parameterization_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ist_5fslam_2fpose_5fgraph_2fproto_2fnode_2eproto__INCLUDED
