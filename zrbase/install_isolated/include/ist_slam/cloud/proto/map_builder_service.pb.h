// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ist_slam/cloud/proto/map_builder_service.proto

#ifndef PROTOBUF_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto__INCLUDED
#define PROTOBUF_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ist_slam/mapping/proto/pose_graph.pb.h"
#include "ist_slam/mapping/proto/serialization.pb.h"
#include "ist_slam/mapping/proto/submap_visualization.pb.h"
#include "ist_slam/mapping/proto/trajectory_builder_options.pb.h"
#include "ist_slam/sensor/proto/sensor.pb.h"
#include "ist_slam/transform/proto/transform.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
namespace ist_slam {
namespace cloud {
namespace proto {
class AddFixedFramePoseDataRequest;
class AddFixedFramePoseDataRequestDefaultTypeInternal;
extern AddFixedFramePoseDataRequestDefaultTypeInternal _AddFixedFramePoseDataRequest_default_instance_;
class AddImuDataRequest;
class AddImuDataRequestDefaultTypeInternal;
extern AddImuDataRequestDefaultTypeInternal _AddImuDataRequest_default_instance_;
class AddLandmarkDataRequest;
class AddLandmarkDataRequestDefaultTypeInternal;
extern AddLandmarkDataRequestDefaultTypeInternal _AddLandmarkDataRequest_default_instance_;
class AddOdometryDataRequest;
class AddOdometryDataRequestDefaultTypeInternal;
extern AddOdometryDataRequestDefaultTypeInternal _AddOdometryDataRequest_default_instance_;
class AddRangefinderDataRequest;
class AddRangefinderDataRequestDefaultTypeInternal;
extern AddRangefinderDataRequestDefaultTypeInternal _AddRangefinderDataRequest_default_instance_;
class AddSensorDataBatchRequest;
class AddSensorDataBatchRequestDefaultTypeInternal;
extern AddSensorDataBatchRequestDefaultTypeInternal _AddSensorDataBatchRequest_default_instance_;
class AddTrajectoryRequest;
class AddTrajectoryRequestDefaultTypeInternal;
extern AddTrajectoryRequestDefaultTypeInternal _AddTrajectoryRequest_default_instance_;
class AddTrajectoryResponse;
class AddTrajectoryResponseDefaultTypeInternal;
extern AddTrajectoryResponseDefaultTypeInternal _AddTrajectoryResponse_default_instance_;
class DeleteTrajectoryRequest;
class DeleteTrajectoryRequestDefaultTypeInternal;
extern DeleteTrajectoryRequestDefaultTypeInternal _DeleteTrajectoryRequest_default_instance_;
class FinishTrajectoryRequest;
class FinishTrajectoryRequestDefaultTypeInternal;
extern FinishTrajectoryRequestDefaultTypeInternal _FinishTrajectoryRequest_default_instance_;
class GetAllSubmapPosesResponse;
class GetAllSubmapPosesResponseDefaultTypeInternal;
extern GetAllSubmapPosesResponseDefaultTypeInternal _GetAllSubmapPosesResponse_default_instance_;
class GetConstraintsResponse;
class GetConstraintsResponseDefaultTypeInternal;
extern GetConstraintsResponseDefaultTypeInternal _GetConstraintsResponse_default_instance_;
class GetLandmarkPosesResponse;
class GetLandmarkPosesResponseDefaultTypeInternal;
extern GetLandmarkPosesResponseDefaultTypeInternal _GetLandmarkPosesResponse_default_instance_;
class GetLocalToGlobalTransformRequest;
class GetLocalToGlobalTransformRequestDefaultTypeInternal;
extern GetLocalToGlobalTransformRequestDefaultTypeInternal _GetLocalToGlobalTransformRequest_default_instance_;
class GetLocalToGlobalTransformResponse;
class GetLocalToGlobalTransformResponseDefaultTypeInternal;
extern GetLocalToGlobalTransformResponseDefaultTypeInternal _GetLocalToGlobalTransformResponse_default_instance_;
class GetSubmapRequest;
class GetSubmapRequestDefaultTypeInternal;
extern GetSubmapRequestDefaultTypeInternal _GetSubmapRequest_default_instance_;
class GetSubmapResponse;
class GetSubmapResponseDefaultTypeInternal;
extern GetSubmapResponseDefaultTypeInternal _GetSubmapResponse_default_instance_;
class GetTrajectoryNodePosesResponse;
class GetTrajectoryNodePosesResponseDefaultTypeInternal;
extern GetTrajectoryNodePosesResponseDefaultTypeInternal _GetTrajectoryNodePosesResponse_default_instance_;
class GetTrajectoryStatesResponse;
class GetTrajectoryStatesResponseDefaultTypeInternal;
extern GetTrajectoryStatesResponseDefaultTypeInternal _GetTrajectoryStatesResponse_default_instance_;
class GetTrajectoryStatesResponse_TrajectoriesStateEntry;
class GetTrajectoryStatesResponse_TrajectoriesStateEntryDefaultTypeInternal;
extern GetTrajectoryStatesResponse_TrajectoriesStateEntryDefaultTypeInternal _GetTrajectoryStatesResponse_TrajectoriesStateEntry_default_instance_;
class IsTrajectoryFinishedRequest;
class IsTrajectoryFinishedRequestDefaultTypeInternal;
extern IsTrajectoryFinishedRequestDefaultTypeInternal _IsTrajectoryFinishedRequest_default_instance_;
class IsTrajectoryFinishedResponse;
class IsTrajectoryFinishedResponseDefaultTypeInternal;
extern IsTrajectoryFinishedResponseDefaultTypeInternal _IsTrajectoryFinishedResponse_default_instance_;
class IsTrajectoryFrozenRequest;
class IsTrajectoryFrozenRequestDefaultTypeInternal;
extern IsTrajectoryFrozenRequestDefaultTypeInternal _IsTrajectoryFrozenRequest_default_instance_;
class IsTrajectoryFrozenResponse;
class IsTrajectoryFrozenResponseDefaultTypeInternal;
extern IsTrajectoryFrozenResponseDefaultTypeInternal _IsTrajectoryFrozenResponse_default_instance_;
class LoadStateFromFileRequest;
class LoadStateFromFileRequestDefaultTypeInternal;
extern LoadStateFromFileRequestDefaultTypeInternal _LoadStateFromFileRequest_default_instance_;
class LoadStateFromFileResponse;
class LoadStateFromFileResponseDefaultTypeInternal;
extern LoadStateFromFileResponseDefaultTypeInternal _LoadStateFromFileResponse_default_instance_;
class LoadStateRequest;
class LoadStateRequestDefaultTypeInternal;
extern LoadStateRequestDefaultTypeInternal _LoadStateRequest_default_instance_;
class LoadStateResponse;
class LoadStateResponseDefaultTypeInternal;
extern LoadStateResponseDefaultTypeInternal _LoadStateResponse_default_instance_;
class LocalSlamInsertionResult;
class LocalSlamInsertionResultDefaultTypeInternal;
extern LocalSlamInsertionResultDefaultTypeInternal _LocalSlamInsertionResult_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse;
class ReceiveGlobalSlamOptimizationsResponseDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponseDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntryDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntryDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_default_instance_;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry;
class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntryDefaultTypeInternal;
extern ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntryDefaultTypeInternal _ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_default_instance_;
class ReceiveLocalSlamResultsRequest;
class ReceiveLocalSlamResultsRequestDefaultTypeInternal;
extern ReceiveLocalSlamResultsRequestDefaultTypeInternal _ReceiveLocalSlamResultsRequest_default_instance_;
class ReceiveLocalSlamResultsResponse;
class ReceiveLocalSlamResultsResponseDefaultTypeInternal;
extern ReceiveLocalSlamResultsResponseDefaultTypeInternal _ReceiveLocalSlamResultsResponse_default_instance_;
class SensorData;
class SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorId;
class SensorIdDefaultTypeInternal;
extern SensorIdDefaultTypeInternal _SensorId_default_instance_;
class SensorMetadata;
class SensorMetadataDefaultTypeInternal;
extern SensorMetadataDefaultTypeInternal _SensorMetadata_default_instance_;
class SetLandmarkPoseRequest;
class SetLandmarkPoseRequestDefaultTypeInternal;
extern SetLandmarkPoseRequestDefaultTypeInternal _SetLandmarkPoseRequest_default_instance_;
class SubmapPose;
class SubmapPoseDefaultTypeInternal;
extern SubmapPoseDefaultTypeInternal _SubmapPose_default_instance_;
class TrajectoryNodePose;
class TrajectoryNodePoseDefaultTypeInternal;
extern TrajectoryNodePoseDefaultTypeInternal _TrajectoryNodePose_default_instance_;
class TrajectoryNodePose_ConstantPoseData;
class TrajectoryNodePose_ConstantPoseDataDefaultTypeInternal;
extern TrajectoryNodePose_ConstantPoseDataDefaultTypeInternal _TrajectoryNodePose_ConstantPoseData_default_instance_;
class TrajectoryRemapping;
class TrajectoryRemappingDefaultTypeInternal;
extern TrajectoryRemappingDefaultTypeInternal _TrajectoryRemapping_default_instance_;
class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry;
class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntryDefaultTypeInternal;
extern TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntryDefaultTypeInternal _TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_default_instance_;
class WriteStateResponse;
class WriteStateResponseDefaultTypeInternal;
extern WriteStateResponseDefaultTypeInternal _WriteStateResponse_default_instance_;
class WriteStateToFileRequest;
class WriteStateToFileRequestDefaultTypeInternal;
extern WriteStateToFileRequestDefaultTypeInternal _WriteStateToFileRequest_default_instance_;
class WriteStateToFileResponse;
class WriteStateToFileResponseDefaultTypeInternal;
extern WriteStateToFileResponseDefaultTypeInternal _WriteStateToFileResponse_default_instance_;
}  // namespace proto
}  // namespace cloud
}  // namespace ist_slam

namespace ist_slam {
namespace cloud {
namespace proto {

namespace protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto

enum SensorType {
  RANGE = 0,
  IMU = 1,
  ODOMETRY = 2,
  FIXED_FRAME_POSE = 3,
  LANDMARK = 4,
  LOCAL_SLAM_RESULT = 5,
  SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = RANGE;
const SensorType SensorType_MAX = LOCAL_SLAM_RESULT;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
enum TrajectoryState {
  ACTIVE = 0,
  FINISHED = 1,
  FROZEN = 2,
  DELETED = 3,
  TrajectoryState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrajectoryState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrajectoryState_IsValid(int value);
const TrajectoryState TrajectoryState_MIN = ACTIVE;
const TrajectoryState TrajectoryState_MAX = DELETED;
const int TrajectoryState_ARRAYSIZE = TrajectoryState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrajectoryState_descriptor();
inline const ::std::string& TrajectoryState_Name(TrajectoryState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrajectoryState_descriptor(), value);
}
inline bool TrajectoryState_Parse(
    const ::std::string& name, TrajectoryState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrajectoryState>(
    TrajectoryState_descriptor(), name, value);
}
// ===================================================================

class SensorId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.SensorId) */ {
 public:
  SensorId();
  virtual ~SensorId();

  SensorId(const SensorId& from);

  inline SensorId& operator=(const SensorId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorId(SensorId&& from) noexcept
    : SensorId() {
    *this = ::std::move(from);
  }

  inline SensorId& operator=(SensorId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorId& default_instance();

  static inline const SensorId* internal_default_instance() {
    return reinterpret_cast<const SensorId*>(
               &_SensorId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SensorId* other);
  friend void swap(SensorId& a, SensorId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorId* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorId& from);
  void MergeFrom(const SensorId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .ist_slam.cloud.proto.SensorType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::ist_slam::cloud::proto::SensorType type() const;
  void set_type(::ist_slam::cloud::proto::SensorType value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.SensorId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddTrajectoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddTrajectoryRequest) */ {
 public:
  AddTrajectoryRequest();
  virtual ~AddTrajectoryRequest();

  AddTrajectoryRequest(const AddTrajectoryRequest& from);

  inline AddTrajectoryRequest& operator=(const AddTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTrajectoryRequest(AddTrajectoryRequest&& from) noexcept
    : AddTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline AddTrajectoryRequest& operator=(AddTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTrajectoryRequest& default_instance();

  static inline const AddTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const AddTrajectoryRequest*>(
               &_AddTrajectoryRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AddTrajectoryRequest* other);
  friend void swap(AddTrajectoryRequest& a, AddTrajectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTrajectoryRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddTrajectoryRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddTrajectoryRequest& from);
  void MergeFrom(const AddTrajectoryRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddTrajectoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ist_slam.cloud.proto.SensorId expected_sensor_ids = 3;
  int expected_sensor_ids_size() const;
  void clear_expected_sensor_ids();
  static const int kExpectedSensorIdsFieldNumber = 3;
  const ::ist_slam::cloud::proto::SensorId& expected_sensor_ids(int index) const;
  ::ist_slam::cloud::proto::SensorId* mutable_expected_sensor_ids(int index);
  ::ist_slam::cloud::proto::SensorId* add_expected_sensor_ids();
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorId >*
      mutable_expected_sensor_ids();
  const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorId >&
      expected_sensor_ids() const;

  // string client_id = 4;
  void clear_client_id();
  static const int kClientIdFieldNumber = 4;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // .ist_slam.mapping.proto.TrajectoryBuilderOptions trajectory_builder_options = 2;
  bool has_trajectory_builder_options() const;
  void clear_trajectory_builder_options();
  static const int kTrajectoryBuilderOptionsFieldNumber = 2;
  const ::ist_slam::mapping::proto::TrajectoryBuilderOptions& trajectory_builder_options() const;
  ::ist_slam::mapping::proto::TrajectoryBuilderOptions* mutable_trajectory_builder_options();
  ::ist_slam::mapping::proto::TrajectoryBuilderOptions* release_trajectory_builder_options();
  void set_allocated_trajectory_builder_options(::ist_slam::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddTrajectoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorId > expected_sensor_ids_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::ist_slam::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorMetadata : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.SensorMetadata) */ {
 public:
  SensorMetadata();
  virtual ~SensorMetadata();

  SensorMetadata(const SensorMetadata& from);

  inline SensorMetadata& operator=(const SensorMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorMetadata(SensorMetadata&& from) noexcept
    : SensorMetadata() {
    *this = ::std::move(from);
  }

  inline SensorMetadata& operator=(SensorMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorMetadata& default_instance();

  static inline const SensorMetadata* internal_default_instance() {
    return reinterpret_cast<const SensorMetadata*>(
               &_SensorMetadata_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SensorMetadata* other);
  friend void swap(SensorMetadata& a, SensorMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorMetadata* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorMetadata* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorMetadata& from);
  void MergeFrom(const SensorMetadata& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sensor_id = 2;
  void clear_sensor_id();
  static const int kSensorIdFieldNumber = 2;
  const ::std::string& sensor_id() const;
  void set_sensor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_id(::std::string&& value);
  #endif
  void set_sensor_id(const char* value);
  void set_sensor_id(const char* value, size_t size);
  ::std::string* mutable_sensor_id();
  ::std::string* release_sensor_id();
  void set_allocated_sensor_id(::std::string* sensor_id);

  // string client_id = 3;
  void clear_client_id();
  static const int kClientIdFieldNumber = 3;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.SensorMetadata)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sensor_id_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.SensorData) */ {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(SensorData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  enum SensorDataCase {
    kOdometryData = 2,
    kImuData = 3,
    kTimedPointCloudData = 4,
    kFixedFramePoseData = 5,
    kLandmarkData = 6,
    kLocalSlamResultData = 7,
    SENSOR_DATA_NOT_SET = 0,
  };

  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SensorData* other);
  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorData* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::ist_slam::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  ::ist_slam::cloud::proto::SensorMetadata* release_sensor_metadata();
  void set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata);

  // .ist_slam.sensor.proto.OdometryData odometry_data = 2;
  bool has_odometry_data() const;
  void clear_odometry_data();
  static const int kOdometryDataFieldNumber = 2;
  const ::ist_slam::sensor::proto::OdometryData& odometry_data() const;
  ::ist_slam::sensor::proto::OdometryData* mutable_odometry_data();
  ::ist_slam::sensor::proto::OdometryData* release_odometry_data();
  void set_allocated_odometry_data(::ist_slam::sensor::proto::OdometryData* odometry_data);

  // .ist_slam.sensor.proto.ImuData imu_data = 3;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 3;
  const ::ist_slam::sensor::proto::ImuData& imu_data() const;
  ::ist_slam::sensor::proto::ImuData* mutable_imu_data();
  ::ist_slam::sensor::proto::ImuData* release_imu_data();
  void set_allocated_imu_data(::ist_slam::sensor::proto::ImuData* imu_data);

  // .ist_slam.sensor.proto.TimedPointCloudData timed_point_cloud_data = 4;
  bool has_timed_point_cloud_data() const;
  void clear_timed_point_cloud_data();
  static const int kTimedPointCloudDataFieldNumber = 4;
  const ::ist_slam::sensor::proto::TimedPointCloudData& timed_point_cloud_data() const;
  ::ist_slam::sensor::proto::TimedPointCloudData* mutable_timed_point_cloud_data();
  ::ist_slam::sensor::proto::TimedPointCloudData* release_timed_point_cloud_data();
  void set_allocated_timed_point_cloud_data(::ist_slam::sensor::proto::TimedPointCloudData* timed_point_cloud_data);

  // .ist_slam.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 5;
  bool has_fixed_frame_pose_data() const;
  void clear_fixed_frame_pose_data();
  static const int kFixedFramePoseDataFieldNumber = 5;
  const ::ist_slam::sensor::proto::FixedFramePoseData& fixed_frame_pose_data() const;
  ::ist_slam::sensor::proto::FixedFramePoseData* mutable_fixed_frame_pose_data();
  ::ist_slam::sensor::proto::FixedFramePoseData* release_fixed_frame_pose_data();
  void set_allocated_fixed_frame_pose_data(::ist_slam::sensor::proto::FixedFramePoseData* fixed_frame_pose_data);

  // .ist_slam.sensor.proto.LandmarkData landmark_data = 6;
  bool has_landmark_data() const;
  void clear_landmark_data();
  static const int kLandmarkDataFieldNumber = 6;
  const ::ist_slam::sensor::proto::LandmarkData& landmark_data() const;
  ::ist_slam::sensor::proto::LandmarkData* mutable_landmark_data();
  ::ist_slam::sensor::proto::LandmarkData* release_landmark_data();
  void set_allocated_landmark_data(::ist_slam::sensor::proto::LandmarkData* landmark_data);

  // .ist_slam.mapping.proto.LocalSlamResultData local_slam_result_data = 7;
  bool has_local_slam_result_data() const;
  void clear_local_slam_result_data();
  static const int kLocalSlamResultDataFieldNumber = 7;
  const ::ist_slam::mapping::proto::LocalSlamResultData& local_slam_result_data() const;
  ::ist_slam::mapping::proto::LocalSlamResultData* mutable_local_slam_result_data();
  ::ist_slam::mapping::proto::LocalSlamResultData* release_local_slam_result_data();
  void set_allocated_local_slam_result_data(::ist_slam::mapping::proto::LocalSlamResultData* local_slam_result_data);

  SensorDataCase sensor_data_case() const;
  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.SensorData)
 private:
  void set_has_odometry_data();
  void set_has_imu_data();
  void set_has_timed_point_cloud_data();
  void set_has_fixed_frame_pose_data();
  void set_has_landmark_data();
  void set_has_local_slam_result_data();

  inline bool has_sensor_data() const;
  void clear_sensor_data();
  inline void clear_has_sensor_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::SensorMetadata* sensor_metadata_;
  union SensorDataUnion {
    SensorDataUnion() {}
    ::ist_slam::sensor::proto::OdometryData* odometry_data_;
    ::ist_slam::sensor::proto::ImuData* imu_data_;
    ::ist_slam::sensor::proto::TimedPointCloudData* timed_point_cloud_data_;
    ::ist_slam::sensor::proto::FixedFramePoseData* fixed_frame_pose_data_;
    ::ist_slam::sensor::proto::LandmarkData* landmark_data_;
    ::ist_slam::mapping::proto::LocalSlamResultData* local_slam_result_data_;
  } sensor_data_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddTrajectoryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddTrajectoryResponse) */ {
 public:
  AddTrajectoryResponse();
  virtual ~AddTrajectoryResponse();

  AddTrajectoryResponse(const AddTrajectoryResponse& from);

  inline AddTrajectoryResponse& operator=(const AddTrajectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTrajectoryResponse(AddTrajectoryResponse&& from) noexcept
    : AddTrajectoryResponse() {
    *this = ::std::move(from);
  }

  inline AddTrajectoryResponse& operator=(AddTrajectoryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTrajectoryResponse& default_instance();

  static inline const AddTrajectoryResponse* internal_default_instance() {
    return reinterpret_cast<const AddTrajectoryResponse*>(
               &_AddTrajectoryResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AddTrajectoryResponse* other);
  friend void swap(AddTrajectoryResponse& a, AddTrajectoryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTrajectoryResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AddTrajectoryResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddTrajectoryResponse& from);
  void MergeFrom(const AddTrajectoryResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddTrajectoryResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddTrajectoryResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddSensorDataBatchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddSensorDataBatchRequest) */ {
 public:
  AddSensorDataBatchRequest();
  virtual ~AddSensorDataBatchRequest();

  AddSensorDataBatchRequest(const AddSensorDataBatchRequest& from);

  inline AddSensorDataBatchRequest& operator=(const AddSensorDataBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddSensorDataBatchRequest(AddSensorDataBatchRequest&& from) noexcept
    : AddSensorDataBatchRequest() {
    *this = ::std::move(from);
  }

  inline AddSensorDataBatchRequest& operator=(AddSensorDataBatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddSensorDataBatchRequest& default_instance();

  static inline const AddSensorDataBatchRequest* internal_default_instance() {
    return reinterpret_cast<const AddSensorDataBatchRequest*>(
               &_AddSensorDataBatchRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AddSensorDataBatchRequest* other);
  friend void swap(AddSensorDataBatchRequest& a, AddSensorDataBatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddSensorDataBatchRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddSensorDataBatchRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddSensorDataBatchRequest& from);
  void MergeFrom(const AddSensorDataBatchRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddSensorDataBatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ist_slam.cloud.proto.SensorData sensor_data = 1;
  int sensor_data_size() const;
  void clear_sensor_data();
  static const int kSensorDataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorData& sensor_data(int index) const;
  ::ist_slam::cloud::proto::SensorData* mutable_sensor_data(int index);
  ::ist_slam::cloud::proto::SensorData* add_sensor_data();
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorData >*
      mutable_sensor_data();
  const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorData >&
      sensor_data() const;

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddSensorDataBatchRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorData > sensor_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddOdometryDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddOdometryDataRequest) */ {
 public:
  AddOdometryDataRequest();
  virtual ~AddOdometryDataRequest();

  AddOdometryDataRequest(const AddOdometryDataRequest& from);

  inline AddOdometryDataRequest& operator=(const AddOdometryDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddOdometryDataRequest(AddOdometryDataRequest&& from) noexcept
    : AddOdometryDataRequest() {
    *this = ::std::move(from);
  }

  inline AddOdometryDataRequest& operator=(AddOdometryDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddOdometryDataRequest& default_instance();

  static inline const AddOdometryDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddOdometryDataRequest*>(
               &_AddOdometryDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AddOdometryDataRequest* other);
  friend void swap(AddOdometryDataRequest& a, AddOdometryDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddOdometryDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddOdometryDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddOdometryDataRequest& from);
  void MergeFrom(const AddOdometryDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddOdometryDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::ist_slam::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  ::ist_slam::cloud::proto::SensorMetadata* release_sensor_metadata();
  void set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata);

  // .ist_slam.sensor.proto.OdometryData odometry_data = 2;
  bool has_odometry_data() const;
  void clear_odometry_data();
  static const int kOdometryDataFieldNumber = 2;
  const ::ist_slam::sensor::proto::OdometryData& odometry_data() const;
  ::ist_slam::sensor::proto::OdometryData* mutable_odometry_data();
  ::ist_slam::sensor::proto::OdometryData* release_odometry_data();
  void set_allocated_odometry_data(::ist_slam::sensor::proto::OdometryData* odometry_data);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddOdometryDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::SensorMetadata* sensor_metadata_;
  ::ist_slam::sensor::proto::OdometryData* odometry_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddImuDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddImuDataRequest) */ {
 public:
  AddImuDataRequest();
  virtual ~AddImuDataRequest();

  AddImuDataRequest(const AddImuDataRequest& from);

  inline AddImuDataRequest& operator=(const AddImuDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddImuDataRequest(AddImuDataRequest&& from) noexcept
    : AddImuDataRequest() {
    *this = ::std::move(from);
  }

  inline AddImuDataRequest& operator=(AddImuDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddImuDataRequest& default_instance();

  static inline const AddImuDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddImuDataRequest*>(
               &_AddImuDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(AddImuDataRequest* other);
  friend void swap(AddImuDataRequest& a, AddImuDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddImuDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddImuDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddImuDataRequest& from);
  void MergeFrom(const AddImuDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddImuDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::ist_slam::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  ::ist_slam::cloud::proto::SensorMetadata* release_sensor_metadata();
  void set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata);

  // .ist_slam.sensor.proto.ImuData imu_data = 2;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 2;
  const ::ist_slam::sensor::proto::ImuData& imu_data() const;
  ::ist_slam::sensor::proto::ImuData* mutable_imu_data();
  ::ist_slam::sensor::proto::ImuData* release_imu_data();
  void set_allocated_imu_data(::ist_slam::sensor::proto::ImuData* imu_data);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddImuDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::SensorMetadata* sensor_metadata_;
  ::ist_slam::sensor::proto::ImuData* imu_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddRangefinderDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddRangefinderDataRequest) */ {
 public:
  AddRangefinderDataRequest();
  virtual ~AddRangefinderDataRequest();

  AddRangefinderDataRequest(const AddRangefinderDataRequest& from);

  inline AddRangefinderDataRequest& operator=(const AddRangefinderDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddRangefinderDataRequest(AddRangefinderDataRequest&& from) noexcept
    : AddRangefinderDataRequest() {
    *this = ::std::move(from);
  }

  inline AddRangefinderDataRequest& operator=(AddRangefinderDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRangefinderDataRequest& default_instance();

  static inline const AddRangefinderDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddRangefinderDataRequest*>(
               &_AddRangefinderDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(AddRangefinderDataRequest* other);
  friend void swap(AddRangefinderDataRequest& a, AddRangefinderDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddRangefinderDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddRangefinderDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddRangefinderDataRequest& from);
  void MergeFrom(const AddRangefinderDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddRangefinderDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::ist_slam::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  ::ist_slam::cloud::proto::SensorMetadata* release_sensor_metadata();
  void set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata);

  // .ist_slam.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
  bool has_timed_point_cloud_data() const;
  void clear_timed_point_cloud_data();
  static const int kTimedPointCloudDataFieldNumber = 2;
  const ::ist_slam::sensor::proto::TimedPointCloudData& timed_point_cloud_data() const;
  ::ist_slam::sensor::proto::TimedPointCloudData* mutable_timed_point_cloud_data();
  ::ist_slam::sensor::proto::TimedPointCloudData* release_timed_point_cloud_data();
  void set_allocated_timed_point_cloud_data(::ist_slam::sensor::proto::TimedPointCloudData* timed_point_cloud_data);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddRangefinderDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::SensorMetadata* sensor_metadata_;
  ::ist_slam::sensor::proto::TimedPointCloudData* timed_point_cloud_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddFixedFramePoseDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddFixedFramePoseDataRequest) */ {
 public:
  AddFixedFramePoseDataRequest();
  virtual ~AddFixedFramePoseDataRequest();

  AddFixedFramePoseDataRequest(const AddFixedFramePoseDataRequest& from);

  inline AddFixedFramePoseDataRequest& operator=(const AddFixedFramePoseDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddFixedFramePoseDataRequest(AddFixedFramePoseDataRequest&& from) noexcept
    : AddFixedFramePoseDataRequest() {
    *this = ::std::move(from);
  }

  inline AddFixedFramePoseDataRequest& operator=(AddFixedFramePoseDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddFixedFramePoseDataRequest& default_instance();

  static inline const AddFixedFramePoseDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddFixedFramePoseDataRequest*>(
               &_AddFixedFramePoseDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(AddFixedFramePoseDataRequest* other);
  friend void swap(AddFixedFramePoseDataRequest& a, AddFixedFramePoseDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddFixedFramePoseDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddFixedFramePoseDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddFixedFramePoseDataRequest& from);
  void MergeFrom(const AddFixedFramePoseDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddFixedFramePoseDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::ist_slam::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  ::ist_slam::cloud::proto::SensorMetadata* release_sensor_metadata();
  void set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata);

  // .ist_slam.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
  bool has_fixed_frame_pose_data() const;
  void clear_fixed_frame_pose_data();
  static const int kFixedFramePoseDataFieldNumber = 2;
  const ::ist_slam::sensor::proto::FixedFramePoseData& fixed_frame_pose_data() const;
  ::ist_slam::sensor::proto::FixedFramePoseData* mutable_fixed_frame_pose_data();
  ::ist_slam::sensor::proto::FixedFramePoseData* release_fixed_frame_pose_data();
  void set_allocated_fixed_frame_pose_data(::ist_slam::sensor::proto::FixedFramePoseData* fixed_frame_pose_data);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddFixedFramePoseDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::SensorMetadata* sensor_metadata_;
  ::ist_slam::sensor::proto::FixedFramePoseData* fixed_frame_pose_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddLandmarkDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.AddLandmarkDataRequest) */ {
 public:
  AddLandmarkDataRequest();
  virtual ~AddLandmarkDataRequest();

  AddLandmarkDataRequest(const AddLandmarkDataRequest& from);

  inline AddLandmarkDataRequest& operator=(const AddLandmarkDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddLandmarkDataRequest(AddLandmarkDataRequest&& from) noexcept
    : AddLandmarkDataRequest() {
    *this = ::std::move(from);
  }

  inline AddLandmarkDataRequest& operator=(AddLandmarkDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddLandmarkDataRequest& default_instance();

  static inline const AddLandmarkDataRequest* internal_default_instance() {
    return reinterpret_cast<const AddLandmarkDataRequest*>(
               &_AddLandmarkDataRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(AddLandmarkDataRequest* other);
  friend void swap(AddLandmarkDataRequest& a, AddLandmarkDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddLandmarkDataRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AddLandmarkDataRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddLandmarkDataRequest& from);
  void MergeFrom(const AddLandmarkDataRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddLandmarkDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
  bool has_sensor_metadata() const;
  void clear_sensor_metadata();
  static const int kSensorMetadataFieldNumber = 1;
  const ::ist_slam::cloud::proto::SensorMetadata& sensor_metadata() const;
  ::ist_slam::cloud::proto::SensorMetadata* mutable_sensor_metadata();
  ::ist_slam::cloud::proto::SensorMetadata* release_sensor_metadata();
  void set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata);

  // .ist_slam.sensor.proto.LandmarkData landmark_data = 2;
  bool has_landmark_data() const;
  void clear_landmark_data();
  static const int kLandmarkDataFieldNumber = 2;
  const ::ist_slam::sensor::proto::LandmarkData& landmark_data() const;
  ::ist_slam::sensor::proto::LandmarkData* mutable_landmark_data();
  ::ist_slam::sensor::proto::LandmarkData* release_landmark_data();
  void set_allocated_landmark_data(::ist_slam::sensor::proto::LandmarkData* landmark_data);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.AddLandmarkDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::SensorMetadata* sensor_metadata_;
  ::ist_slam::sensor::proto::LandmarkData* landmark_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FinishTrajectoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.FinishTrajectoryRequest) */ {
 public:
  FinishTrajectoryRequest();
  virtual ~FinishTrajectoryRequest();

  FinishTrajectoryRequest(const FinishTrajectoryRequest& from);

  inline FinishTrajectoryRequest& operator=(const FinishTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FinishTrajectoryRequest(FinishTrajectoryRequest&& from) noexcept
    : FinishTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline FinishTrajectoryRequest& operator=(FinishTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishTrajectoryRequest& default_instance();

  static inline const FinishTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const FinishTrajectoryRequest*>(
               &_FinishTrajectoryRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(FinishTrajectoryRequest* other);
  friend void swap(FinishTrajectoryRequest& a, FinishTrajectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishTrajectoryRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FinishTrajectoryRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FinishTrajectoryRequest& from);
  void MergeFrom(const FinishTrajectoryRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FinishTrajectoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.FinishTrajectoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteTrajectoryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.DeleteTrajectoryRequest) */ {
 public:
  DeleteTrajectoryRequest();
  virtual ~DeleteTrajectoryRequest();

  DeleteTrajectoryRequest(const DeleteTrajectoryRequest& from);

  inline DeleteTrajectoryRequest& operator=(const DeleteTrajectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteTrajectoryRequest(DeleteTrajectoryRequest&& from) noexcept
    : DeleteTrajectoryRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTrajectoryRequest& operator=(DeleteTrajectoryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteTrajectoryRequest& default_instance();

  static inline const DeleteTrajectoryRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTrajectoryRequest*>(
               &_DeleteTrajectoryRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DeleteTrajectoryRequest* other);
  friend void swap(DeleteTrajectoryRequest& a, DeleteTrajectoryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteTrajectoryRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteTrajectoryRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteTrajectoryRequest& from);
  void MergeFrom(const DeleteTrajectoryRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteTrajectoryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.DeleteTrajectoryRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceiveLocalSlamResultsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.ReceiveLocalSlamResultsRequest) */ {
 public:
  ReceiveLocalSlamResultsRequest();
  virtual ~ReceiveLocalSlamResultsRequest();

  ReceiveLocalSlamResultsRequest(const ReceiveLocalSlamResultsRequest& from);

  inline ReceiveLocalSlamResultsRequest& operator=(const ReceiveLocalSlamResultsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveLocalSlamResultsRequest(ReceiveLocalSlamResultsRequest&& from) noexcept
    : ReceiveLocalSlamResultsRequest() {
    *this = ::std::move(from);
  }

  inline ReceiveLocalSlamResultsRequest& operator=(ReceiveLocalSlamResultsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveLocalSlamResultsRequest& default_instance();

  static inline const ReceiveLocalSlamResultsRequest* internal_default_instance() {
    return reinterpret_cast<const ReceiveLocalSlamResultsRequest*>(
               &_ReceiveLocalSlamResultsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ReceiveLocalSlamResultsRequest* other);
  friend void swap(ReceiveLocalSlamResultsRequest& a, ReceiveLocalSlamResultsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveLocalSlamResultsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReceiveLocalSlamResultsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReceiveLocalSlamResultsRequest& from);
  void MergeFrom(const ReceiveLocalSlamResultsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReceiveLocalSlamResultsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.ReceiveLocalSlamResultsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalSlamInsertionResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.LocalSlamInsertionResult) */ {
 public:
  LocalSlamInsertionResult();
  virtual ~LocalSlamInsertionResult();

  LocalSlamInsertionResult(const LocalSlamInsertionResult& from);

  inline LocalSlamInsertionResult& operator=(const LocalSlamInsertionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalSlamInsertionResult(LocalSlamInsertionResult&& from) noexcept
    : LocalSlamInsertionResult() {
    *this = ::std::move(from);
  }

  inline LocalSlamInsertionResult& operator=(LocalSlamInsertionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSlamInsertionResult& default_instance();

  static inline const LocalSlamInsertionResult* internal_default_instance() {
    return reinterpret_cast<const LocalSlamInsertionResult*>(
               &_LocalSlamInsertionResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(LocalSlamInsertionResult* other);
  friend void swap(LocalSlamInsertionResult& a, LocalSlamInsertionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalSlamInsertionResult* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalSlamInsertionResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocalSlamInsertionResult& from);
  void MergeFrom(const LocalSlamInsertionResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocalSlamInsertionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.mapping.proto.NodeId node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::ist_slam::mapping::proto::NodeId& node_id() const;
  ::ist_slam::mapping::proto::NodeId* mutable_node_id();
  ::ist_slam::mapping::proto::NodeId* release_node_id();
  void set_allocated_node_id(::ist_slam::mapping::proto::NodeId* node_id);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.LocalSlamInsertionResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::mapping::proto::NodeId* node_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReceiveLocalSlamResultsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse) */ {
 public:
  ReceiveLocalSlamResultsResponse();
  virtual ~ReceiveLocalSlamResultsResponse();

  ReceiveLocalSlamResultsResponse(const ReceiveLocalSlamResultsResponse& from);

  inline ReceiveLocalSlamResultsResponse& operator=(const ReceiveLocalSlamResultsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveLocalSlamResultsResponse(ReceiveLocalSlamResultsResponse&& from) noexcept
    : ReceiveLocalSlamResultsResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveLocalSlamResultsResponse& operator=(ReceiveLocalSlamResultsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveLocalSlamResultsResponse& default_instance();

  static inline const ReceiveLocalSlamResultsResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveLocalSlamResultsResponse*>(
               &_ReceiveLocalSlamResultsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ReceiveLocalSlamResultsResponse* other);
  friend void swap(ReceiveLocalSlamResultsResponse& a, ReceiveLocalSlamResultsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveLocalSlamResultsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReceiveLocalSlamResultsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReceiveLocalSlamResultsResponse& from);
  void MergeFrom(const ReceiveLocalSlamResultsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReceiveLocalSlamResultsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.transform.proto.Rigid3d local_pose = 3;
  bool has_local_pose() const;
  void clear_local_pose();
  static const int kLocalPoseFieldNumber = 3;
  const ::ist_slam::transform::proto::Rigid3d& local_pose() const;
  ::ist_slam::transform::proto::Rigid3d* mutable_local_pose();
  ::ist_slam::transform::proto::Rigid3d* release_local_pose();
  void set_allocated_local_pose(::ist_slam::transform::proto::Rigid3d* local_pose);

  // .ist_slam.sensor.proto.RangeData range_data = 4;
  bool has_range_data() const;
  void clear_range_data();
  static const int kRangeDataFieldNumber = 4;
  const ::ist_slam::sensor::proto::RangeData& range_data() const;
  ::ist_slam::sensor::proto::RangeData* mutable_range_data();
  ::ist_slam::sensor::proto::RangeData* release_range_data();
  void set_allocated_range_data(::ist_slam::sensor::proto::RangeData* range_data);

  // .ist_slam.cloud.proto.LocalSlamInsertionResult insertion_result = 5;
  bool has_insertion_result() const;
  void clear_insertion_result();
  static const int kInsertionResultFieldNumber = 5;
  const ::ist_slam::cloud::proto::LocalSlamInsertionResult& insertion_result() const;
  ::ist_slam::cloud::proto::LocalSlamInsertionResult* mutable_insertion_result();
  ::ist_slam::cloud::proto::LocalSlamInsertionResult* release_insertion_result();
  void set_allocated_insertion_result(::ist_slam::cloud::proto::LocalSlamInsertionResult* insertion_result);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::transform::proto::Rigid3d* local_pose_;
  ::ist_slam::sensor::proto::RangeData* range_data_;
  ::ist_slam::cloud::proto::LocalSlamInsertionResult* insertion_result_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------


// -------------------------------------------------------------------

class ReceiveGlobalSlamOptimizationsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.ReceiveGlobalSlamOptimizationsResponse) */ {
 public:
  ReceiveGlobalSlamOptimizationsResponse();
  virtual ~ReceiveGlobalSlamOptimizationsResponse();

  ReceiveGlobalSlamOptimizationsResponse(const ReceiveGlobalSlamOptimizationsResponse& from);

  inline ReceiveGlobalSlamOptimizationsResponse& operator=(const ReceiveGlobalSlamOptimizationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReceiveGlobalSlamOptimizationsResponse(ReceiveGlobalSlamOptimizationsResponse&& from) noexcept
    : ReceiveGlobalSlamOptimizationsResponse() {
    *this = ::std::move(from);
  }

  inline ReceiveGlobalSlamOptimizationsResponse& operator=(ReceiveGlobalSlamOptimizationsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveGlobalSlamOptimizationsResponse& default_instance();

  static inline const ReceiveGlobalSlamOptimizationsResponse* internal_default_instance() {
    return reinterpret_cast<const ReceiveGlobalSlamOptimizationsResponse*>(
               &_ReceiveGlobalSlamOptimizationsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ReceiveGlobalSlamOptimizationsResponse* other);
  friend void swap(ReceiveGlobalSlamOptimizationsResponse& a, ReceiveGlobalSlamOptimizationsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReceiveGlobalSlamOptimizationsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReceiveGlobalSlamOptimizationsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReceiveGlobalSlamOptimizationsResponse& from);
  void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReceiveGlobalSlamOptimizationsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .ist_slam.mapping.proto.NodeId> last_optimized_node_ids = 1;
  int last_optimized_node_ids_size() const;
  void clear_last_optimized_node_ids();
  static const int kLastOptimizedNodeIdsFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId >&
      last_optimized_node_ids() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId >*
      mutable_last_optimized_node_ids();

  // map<int32, .ist_slam.mapping.proto.SubmapId> last_optimized_submap_ids = 2;
  int last_optimized_submap_ids_size() const;
  void clear_last_optimized_submap_ids();
  static const int kLastOptimizedSubmapIdsFieldNumber = 2;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId >&
      last_optimized_submap_ids() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId >*
      mutable_last_optimized_submap_ids();

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.ReceiveGlobalSlamOptimizationsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry : public ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry, 
      ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry, 
      ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry();
    ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      ReceiveGlobalSlamOptimizationsResponse_LastOptimizedNodeIdsEntry,
      ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > last_optimized_node_ids_;
  private:
  public:
  class ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry : public ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry, 
      ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry, 
      ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry();
    ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      ReceiveGlobalSlamOptimizationsResponse_LastOptimizedSubmapIdsEntry,
      ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > last_optimized_submap_ids_;
  private:
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubmapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetSubmapRequest) */ {
 public:
  GetSubmapRequest();
  virtual ~GetSubmapRequest();

  GetSubmapRequest(const GetSubmapRequest& from);

  inline GetSubmapRequest& operator=(const GetSubmapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubmapRequest(GetSubmapRequest&& from) noexcept
    : GetSubmapRequest() {
    *this = ::std::move(from);
  }

  inline GetSubmapRequest& operator=(GetSubmapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubmapRequest& default_instance();

  static inline const GetSubmapRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubmapRequest*>(
               &_GetSubmapRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(GetSubmapRequest* other);
  friend void swap(GetSubmapRequest& a, GetSubmapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubmapRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetSubmapRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSubmapRequest& from);
  void MergeFrom(const GetSubmapRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSubmapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.mapping.proto.SubmapId submap_id = 1;
  bool has_submap_id() const;
  void clear_submap_id();
  static const int kSubmapIdFieldNumber = 1;
  const ::ist_slam::mapping::proto::SubmapId& submap_id() const;
  ::ist_slam::mapping::proto::SubmapId* mutable_submap_id();
  ::ist_slam::mapping::proto::SubmapId* release_submap_id();
  void set_allocated_submap_id(::ist_slam::mapping::proto::SubmapId* submap_id);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetSubmapRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::mapping::proto::SubmapId* submap_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.LoadStateRequest) */ {
 public:
  LoadStateRequest();
  virtual ~LoadStateRequest();

  LoadStateRequest(const LoadStateRequest& from);

  inline LoadStateRequest& operator=(const LoadStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateRequest(LoadStateRequest&& from) noexcept
    : LoadStateRequest() {
    *this = ::std::move(from);
  }

  inline LoadStateRequest& operator=(LoadStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateRequest& default_instance();

  enum StateChunkCase {
    kSerializedData = 1,
    kSerializationHeader = 2,
    kClientId = 3,
    STATE_CHUNK_NOT_SET = 0,
  };

  static inline const LoadStateRequest* internal_default_instance() {
    return reinterpret_cast<const LoadStateRequest*>(
               &_LoadStateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(LoadStateRequest* other);
  friend void swap(LoadStateRequest& a, LoadStateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadStateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadStateRequest& from);
  void MergeFrom(const LoadStateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool load_frozen_state = 4;
  void clear_load_frozen_state();
  static const int kLoadFrozenStateFieldNumber = 4;
  bool load_frozen_state() const;
  void set_load_frozen_state(bool value);

  // .ist_slam.mapping.proto.SerializedData serialized_data = 1;
  bool has_serialized_data() const;
  void clear_serialized_data();
  static const int kSerializedDataFieldNumber = 1;
  const ::ist_slam::mapping::proto::SerializedData& serialized_data() const;
  ::ist_slam::mapping::proto::SerializedData* mutable_serialized_data();
  ::ist_slam::mapping::proto::SerializedData* release_serialized_data();
  void set_allocated_serialized_data(::ist_slam::mapping::proto::SerializedData* serialized_data);

  // .ist_slam.mapping.proto.SerializationHeader serialization_header = 2;
  bool has_serialization_header() const;
  void clear_serialization_header();
  static const int kSerializationHeaderFieldNumber = 2;
  const ::ist_slam::mapping::proto::SerializationHeader& serialization_header() const;
  ::ist_slam::mapping::proto::SerializationHeader* mutable_serialization_header();
  ::ist_slam::mapping::proto::SerializationHeader* release_serialization_header();
  void set_allocated_serialization_header(::ist_slam::mapping::proto::SerializationHeader* serialization_header);

  // string client_id = 3;
  private:
  bool has_client_id() const;
  public:
  void clear_client_id();
  static const int kClientIdFieldNumber = 3;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  StateChunkCase state_chunk_case() const;
  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.LoadStateRequest)
 private:
  void set_has_serialized_data();
  void set_has_serialization_header();
  void set_has_client_id();

  inline bool has_state_chunk() const;
  void clear_state_chunk();
  inline void clear_has_state_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool load_frozen_state_;
  union StateChunkUnion {
    StateChunkUnion() {}
    ::ist_slam::mapping::proto::SerializedData* serialized_data_;
    ::ist_slam::mapping::proto::SerializationHeader* serialization_header_;
    ::google::protobuf::internal::ArenaStringPtr client_id_;
  } state_chunk_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class TrajectoryRemapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.TrajectoryRemapping) */ {
 public:
  TrajectoryRemapping();
  virtual ~TrajectoryRemapping();

  TrajectoryRemapping(const TrajectoryRemapping& from);

  inline TrajectoryRemapping& operator=(const TrajectoryRemapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryRemapping(TrajectoryRemapping&& from) noexcept
    : TrajectoryRemapping() {
    *this = ::std::move(from);
  }

  inline TrajectoryRemapping& operator=(TrajectoryRemapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryRemapping& default_instance();

  static inline const TrajectoryRemapping* internal_default_instance() {
    return reinterpret_cast<const TrajectoryRemapping*>(
               &_TrajectoryRemapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(TrajectoryRemapping* other);
  friend void swap(TrajectoryRemapping& a, TrajectoryRemapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryRemapping* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryRemapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryRemapping& from);
  void MergeFrom(const TrajectoryRemapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryRemapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, int32> serialized_trajectories_to_trajectories = 1;
  int serialized_trajectories_to_trajectories_size() const;
  void clear_serialized_trajectories_to_trajectories();
  static const int kSerializedTrajectoriesToTrajectoriesFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >&
      serialized_trajectories_to_trajectories() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >*
      mutable_serialized_trajectories_to_trajectories();

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.TrajectoryRemapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry : public ::google::protobuf::internal::MapEntry<TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry, 
      ::google::protobuf::int32, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry, 
      ::google::protobuf::int32, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > SuperType;
    TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry();
    TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      TrajectoryRemapping_SerializedTrajectoriesToTrajectoriesEntry,
      ::google::protobuf::int32, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > serialized_trajectories_to_trajectories_;
  private:
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.LoadStateResponse) */ {
 public:
  LoadStateResponse();
  virtual ~LoadStateResponse();

  LoadStateResponse(const LoadStateResponse& from);

  inline LoadStateResponse& operator=(const LoadStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateResponse(LoadStateResponse&& from) noexcept
    : LoadStateResponse() {
    *this = ::std::move(from);
  }

  inline LoadStateResponse& operator=(LoadStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateResponse& default_instance();

  static inline const LoadStateResponse* internal_default_instance() {
    return reinterpret_cast<const LoadStateResponse*>(
               &_LoadStateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(LoadStateResponse* other);
  friend void swap(LoadStateResponse& a, LoadStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadStateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadStateResponse& from);
  void MergeFrom(const LoadStateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
  bool has_trajectory_remapping() const;
  void clear_trajectory_remapping();
  static const int kTrajectoryRemappingFieldNumber = 1;
  const ::ist_slam::cloud::proto::TrajectoryRemapping& trajectory_remapping() const;
  ::ist_slam::cloud::proto::TrajectoryRemapping* mutable_trajectory_remapping();
  ::ist_slam::cloud::proto::TrajectoryRemapping* release_trajectory_remapping();
  void set_allocated_trajectory_remapping(::ist_slam::cloud::proto::TrajectoryRemapping* trajectory_remapping);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.LoadStateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::TrajectoryRemapping* trajectory_remapping_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateFromFileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.LoadStateFromFileRequest) */ {
 public:
  LoadStateFromFileRequest();
  virtual ~LoadStateFromFileRequest();

  LoadStateFromFileRequest(const LoadStateFromFileRequest& from);

  inline LoadStateFromFileRequest& operator=(const LoadStateFromFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateFromFileRequest(LoadStateFromFileRequest&& from) noexcept
    : LoadStateFromFileRequest() {
    *this = ::std::move(from);
  }

  inline LoadStateFromFileRequest& operator=(LoadStateFromFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateFromFileRequest& default_instance();

  static inline const LoadStateFromFileRequest* internal_default_instance() {
    return reinterpret_cast<const LoadStateFromFileRequest*>(
               &_LoadStateFromFileRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(LoadStateFromFileRequest* other);
  friend void swap(LoadStateFromFileRequest& a, LoadStateFromFileRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateFromFileRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadStateFromFileRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadStateFromFileRequest& from);
  void MergeFrom(const LoadStateFromFileRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadStateFromFileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_file_path(::std::string&& value);
  #endif
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // string client_id = 2;
  void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // bool load_frozen_state = 3;
  void clear_load_frozen_state();
  static const int kLoadFrozenStateFieldNumber = 3;
  bool load_frozen_state() const;
  void set_load_frozen_state(bool value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.LoadStateFromFileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  bool load_frozen_state_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadStateFromFileResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.LoadStateFromFileResponse) */ {
 public:
  LoadStateFromFileResponse();
  virtual ~LoadStateFromFileResponse();

  LoadStateFromFileResponse(const LoadStateFromFileResponse& from);

  inline LoadStateFromFileResponse& operator=(const LoadStateFromFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoadStateFromFileResponse(LoadStateFromFileResponse&& from) noexcept
    : LoadStateFromFileResponse() {
    *this = ::std::move(from);
  }

  inline LoadStateFromFileResponse& operator=(LoadStateFromFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadStateFromFileResponse& default_instance();

  static inline const LoadStateFromFileResponse* internal_default_instance() {
    return reinterpret_cast<const LoadStateFromFileResponse*>(
               &_LoadStateFromFileResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(LoadStateFromFileResponse* other);
  friend void swap(LoadStateFromFileResponse& a, LoadStateFromFileResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoadStateFromFileResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadStateFromFileResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadStateFromFileResponse& from);
  void MergeFrom(const LoadStateFromFileResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadStateFromFileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
  bool has_trajectory_remapping() const;
  void clear_trajectory_remapping();
  static const int kTrajectoryRemappingFieldNumber = 1;
  const ::ist_slam::cloud::proto::TrajectoryRemapping& trajectory_remapping() const;
  ::ist_slam::cloud::proto::TrajectoryRemapping* mutable_trajectory_remapping();
  ::ist_slam::cloud::proto::TrajectoryRemapping* release_trajectory_remapping();
  void set_allocated_trajectory_remapping(::ist_slam::cloud::proto::TrajectoryRemapping* trajectory_remapping);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.LoadStateFromFileResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::cloud::proto::TrajectoryRemapping* trajectory_remapping_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubmapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetSubmapResponse) */ {
 public:
  GetSubmapResponse();
  virtual ~GetSubmapResponse();

  GetSubmapResponse(const GetSubmapResponse& from);

  inline GetSubmapResponse& operator=(const GetSubmapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubmapResponse(GetSubmapResponse&& from) noexcept
    : GetSubmapResponse() {
    *this = ::std::move(from);
  }

  inline GetSubmapResponse& operator=(GetSubmapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubmapResponse& default_instance();

  static inline const GetSubmapResponse* internal_default_instance() {
    return reinterpret_cast<const GetSubmapResponse*>(
               &_GetSubmapResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(GetSubmapResponse* other);
  friend void swap(GetSubmapResponse& a, GetSubmapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubmapResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetSubmapResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSubmapResponse& from);
  void MergeFrom(const GetSubmapResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSubmapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_msg = 2;
  void clear_error_msg();
  static const int kErrorMsgFieldNumber = 2;
  const ::std::string& error_msg() const;
  void set_error_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_error_msg(::std::string&& value);
  #endif
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  ::std::string* mutable_error_msg();
  ::std::string* release_error_msg();
  void set_allocated_error_msg(::std::string* error_msg);

  // .ist_slam.mapping.proto.SubmapQuery.Response submap_query_response = 1;
  bool has_submap_query_response() const;
  void clear_submap_query_response();
  static const int kSubmapQueryResponseFieldNumber = 1;
  const ::ist_slam::mapping::proto::SubmapQuery_Response& submap_query_response() const;
  ::ist_slam::mapping::proto::SubmapQuery_Response* mutable_submap_query_response();
  ::ist_slam::mapping::proto::SubmapQuery_Response* release_submap_query_response();
  void set_allocated_submap_query_response(::ist_slam::mapping::proto::SubmapQuery_Response* submap_query_response);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetSubmapResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_msg_;
  ::ist_slam::mapping::proto::SubmapQuery_Response* submap_query_response_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryNodePose_ConstantPoseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData) */ {
 public:
  TrajectoryNodePose_ConstantPoseData();
  virtual ~TrajectoryNodePose_ConstantPoseData();

  TrajectoryNodePose_ConstantPoseData(const TrajectoryNodePose_ConstantPoseData& from);

  inline TrajectoryNodePose_ConstantPoseData& operator=(const TrajectoryNodePose_ConstantPoseData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryNodePose_ConstantPoseData(TrajectoryNodePose_ConstantPoseData&& from) noexcept
    : TrajectoryNodePose_ConstantPoseData() {
    *this = ::std::move(from);
  }

  inline TrajectoryNodePose_ConstantPoseData& operator=(TrajectoryNodePose_ConstantPoseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryNodePose_ConstantPoseData& default_instance();

  static inline const TrajectoryNodePose_ConstantPoseData* internal_default_instance() {
    return reinterpret_cast<const TrajectoryNodePose_ConstantPoseData*>(
               &_TrajectoryNodePose_ConstantPoseData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(TrajectoryNodePose_ConstantPoseData* other);
  friend void swap(TrajectoryNodePose_ConstantPoseData& a, TrajectoryNodePose_ConstantPoseData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryNodePose_ConstantPoseData* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryNodePose_ConstantPoseData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryNodePose_ConstantPoseData& from);
  void MergeFrom(const TrajectoryNodePose_ConstantPoseData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryNodePose_ConstantPoseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.transform.proto.Rigid3d local_pose = 2;
  bool has_local_pose() const;
  void clear_local_pose();
  static const int kLocalPoseFieldNumber = 2;
  const ::ist_slam::transform::proto::Rigid3d& local_pose() const;
  ::ist_slam::transform::proto::Rigid3d* mutable_local_pose();
  ::ist_slam::transform::proto::Rigid3d* release_local_pose();
  void set_allocated_local_pose(::ist_slam::transform::proto::Rigid3d* local_pose);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::transform::proto::Rigid3d* local_pose_;
  ::google::protobuf::int64 timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryNodePose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.TrajectoryNodePose) */ {
 public:
  TrajectoryNodePose();
  virtual ~TrajectoryNodePose();

  TrajectoryNodePose(const TrajectoryNodePose& from);

  inline TrajectoryNodePose& operator=(const TrajectoryNodePose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryNodePose(TrajectoryNodePose&& from) noexcept
    : TrajectoryNodePose() {
    *this = ::std::move(from);
  }

  inline TrajectoryNodePose& operator=(TrajectoryNodePose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryNodePose& default_instance();

  static inline const TrajectoryNodePose* internal_default_instance() {
    return reinterpret_cast<const TrajectoryNodePose*>(
               &_TrajectoryNodePose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(TrajectoryNodePose* other);
  friend void swap(TrajectoryNodePose& a, TrajectoryNodePose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryNodePose* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryNodePose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryNodePose& from);
  void MergeFrom(const TrajectoryNodePose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryNodePose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TrajectoryNodePose_ConstantPoseData ConstantPoseData;

  // accessors -------------------------------------------------------

  // .ist_slam.mapping.proto.NodeId node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::ist_slam::mapping::proto::NodeId& node_id() const;
  ::ist_slam::mapping::proto::NodeId* mutable_node_id();
  ::ist_slam::mapping::proto::NodeId* release_node_id();
  void set_allocated_node_id(::ist_slam::mapping::proto::NodeId* node_id);

  // .ist_slam.transform.proto.Rigid3d global_pose = 2;
  bool has_global_pose() const;
  void clear_global_pose();
  static const int kGlobalPoseFieldNumber = 2;
  const ::ist_slam::transform::proto::Rigid3d& global_pose() const;
  ::ist_slam::transform::proto::Rigid3d* mutable_global_pose();
  ::ist_slam::transform::proto::Rigid3d* release_global_pose();
  void set_allocated_global_pose(::ist_slam::transform::proto::Rigid3d* global_pose);

  // .ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData constant_pose_data = 3;
  bool has_constant_pose_data() const;
  void clear_constant_pose_data();
  static const int kConstantPoseDataFieldNumber = 3;
  const ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData& constant_pose_data() const;
  ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* mutable_constant_pose_data();
  ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* release_constant_pose_data();
  void set_allocated_constant_pose_data(::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.TrajectoryNodePose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::mapping::proto::NodeId* node_id_;
  ::ist_slam::transform::proto::Rigid3d* global_pose_;
  ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTrajectoryNodePosesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse) */ {
 public:
  GetTrajectoryNodePosesResponse();
  virtual ~GetTrajectoryNodePosesResponse();

  GetTrajectoryNodePosesResponse(const GetTrajectoryNodePosesResponse& from);

  inline GetTrajectoryNodePosesResponse& operator=(const GetTrajectoryNodePosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTrajectoryNodePosesResponse(GetTrajectoryNodePosesResponse&& from) noexcept
    : GetTrajectoryNodePosesResponse() {
    *this = ::std::move(from);
  }

  inline GetTrajectoryNodePosesResponse& operator=(GetTrajectoryNodePosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTrajectoryNodePosesResponse& default_instance();

  static inline const GetTrajectoryNodePosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrajectoryNodePosesResponse*>(
               &_GetTrajectoryNodePosesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(GetTrajectoryNodePosesResponse* other);
  friend void swap(GetTrajectoryNodePosesResponse& a, GetTrajectoryNodePosesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTrajectoryNodePosesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTrajectoryNodePosesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTrajectoryNodePosesResponse& from);
  void MergeFrom(const GetTrajectoryNodePosesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTrajectoryNodePosesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ist_slam.cloud.proto.TrajectoryNodePose node_poses = 1;
  int node_poses_size() const;
  void clear_node_poses();
  static const int kNodePosesFieldNumber = 1;
  const ::ist_slam::cloud::proto::TrajectoryNodePose& node_poses(int index) const;
  ::ist_slam::cloud::proto::TrajectoryNodePose* mutable_node_poses(int index);
  ::ist_slam::cloud::proto::TrajectoryNodePose* add_node_poses();
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::TrajectoryNodePose >*
      mutable_node_poses();
  const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::TrajectoryNodePose >&
      node_poses() const;

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::TrajectoryNodePose > node_poses_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class GetTrajectoryStatesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetTrajectoryStatesResponse) */ {
 public:
  GetTrajectoryStatesResponse();
  virtual ~GetTrajectoryStatesResponse();

  GetTrajectoryStatesResponse(const GetTrajectoryStatesResponse& from);

  inline GetTrajectoryStatesResponse& operator=(const GetTrajectoryStatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTrajectoryStatesResponse(GetTrajectoryStatesResponse&& from) noexcept
    : GetTrajectoryStatesResponse() {
    *this = ::std::move(from);
  }

  inline GetTrajectoryStatesResponse& operator=(GetTrajectoryStatesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTrajectoryStatesResponse& default_instance();

  static inline const GetTrajectoryStatesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTrajectoryStatesResponse*>(
               &_GetTrajectoryStatesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(GetTrajectoryStatesResponse* other);
  friend void swap(GetTrajectoryStatesResponse& a, GetTrajectoryStatesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTrajectoryStatesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTrajectoryStatesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTrajectoryStatesResponse& from);
  void MergeFrom(const GetTrajectoryStatesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTrajectoryStatesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .ist_slam.cloud.proto.TrajectoryState> trajectories_state = 1;
  int trajectories_state_size() const;
  void clear_trajectories_state();
  static const int kTrajectoriesStateFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState >&
      trajectories_state() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState >*
      mutable_trajectories_state();

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetTrajectoryStatesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class GetTrajectoryStatesResponse_TrajectoriesStateEntry : public ::google::protobuf::internal::MapEntry<GetTrajectoryStatesResponse_TrajectoriesStateEntry, 
      ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<GetTrajectoryStatesResponse_TrajectoriesStateEntry, 
      ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 > SuperType;
    GetTrajectoryStatesResponse_TrajectoriesStateEntry();
    GetTrajectoryStatesResponse_TrajectoriesStateEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const GetTrajectoryStatesResponse_TrajectoriesStateEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_GetTrajectoryStatesResponse_TrajectoriesStateEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      GetTrajectoryStatesResponse_TrajectoriesStateEntry,
      ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_ENUM,
      0 > trajectories_state_;
  private:
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLandmarkPosesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetLandmarkPosesResponse) */ {
 public:
  GetLandmarkPosesResponse();
  virtual ~GetLandmarkPosesResponse();

  GetLandmarkPosesResponse(const GetLandmarkPosesResponse& from);

  inline GetLandmarkPosesResponse& operator=(const GetLandmarkPosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLandmarkPosesResponse(GetLandmarkPosesResponse&& from) noexcept
    : GetLandmarkPosesResponse() {
    *this = ::std::move(from);
  }

  inline GetLandmarkPosesResponse& operator=(GetLandmarkPosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLandmarkPosesResponse& default_instance();

  static inline const GetLandmarkPosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetLandmarkPosesResponse*>(
               &_GetLandmarkPosesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(GetLandmarkPosesResponse* other);
  friend void swap(GetLandmarkPosesResponse& a, GetLandmarkPosesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLandmarkPosesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLandmarkPosesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLandmarkPosesResponse& from);
  void MergeFrom(const GetLandmarkPosesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLandmarkPosesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ist_slam.mapping.proto.PoseGraph.LandmarkPose landmark_poses = 1;
  int landmark_poses_size() const;
  void clear_landmark_poses();
  static const int kLandmarkPosesFieldNumber = 1;
  const ::ist_slam::mapping::proto::PoseGraph_LandmarkPose& landmark_poses(int index) const;
  ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* mutable_landmark_poses(int index);
  ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* add_landmark_poses();
  ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_LandmarkPose >*
      mutable_landmark_poses();
  const ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_LandmarkPose >&
      landmark_poses() const;

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetLandmarkPosesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_LandmarkPose > landmark_poses_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetLandmarkPoseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.SetLandmarkPoseRequest) */ {
 public:
  SetLandmarkPoseRequest();
  virtual ~SetLandmarkPoseRequest();

  SetLandmarkPoseRequest(const SetLandmarkPoseRequest& from);

  inline SetLandmarkPoseRequest& operator=(const SetLandmarkPoseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetLandmarkPoseRequest(SetLandmarkPoseRequest&& from) noexcept
    : SetLandmarkPoseRequest() {
    *this = ::std::move(from);
  }

  inline SetLandmarkPoseRequest& operator=(SetLandmarkPoseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLandmarkPoseRequest& default_instance();

  static inline const SetLandmarkPoseRequest* internal_default_instance() {
    return reinterpret_cast<const SetLandmarkPoseRequest*>(
               &_SetLandmarkPoseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(SetLandmarkPoseRequest* other);
  friend void swap(SetLandmarkPoseRequest& a, SetLandmarkPoseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetLandmarkPoseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SetLandmarkPoseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetLandmarkPoseRequest& from);
  void MergeFrom(const SetLandmarkPoseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetLandmarkPoseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.mapping.proto.PoseGraph.LandmarkPose landmark_pose = 1;
  bool has_landmark_pose() const;
  void clear_landmark_pose();
  static const int kLandmarkPoseFieldNumber = 1;
  const ::ist_slam::mapping::proto::PoseGraph_LandmarkPose& landmark_pose() const;
  ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* mutable_landmark_pose();
  ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* release_landmark_pose();
  void set_allocated_landmark_pose(::ist_slam::mapping::proto::PoseGraph_LandmarkPose* landmark_pose);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.SetLandmarkPoseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* landmark_pose_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubmapPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.SubmapPose) */ {
 public:
  SubmapPose();
  virtual ~SubmapPose();

  SubmapPose(const SubmapPose& from);

  inline SubmapPose& operator=(const SubmapPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubmapPose(SubmapPose&& from) noexcept
    : SubmapPose() {
    *this = ::std::move(from);
  }

  inline SubmapPose& operator=(SubmapPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmapPose& default_instance();

  static inline const SubmapPose* internal_default_instance() {
    return reinterpret_cast<const SubmapPose*>(
               &_SubmapPose_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(SubmapPose* other);
  friend void swap(SubmapPose& a, SubmapPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubmapPose* New() const PROTOBUF_FINAL { return New(NULL); }

  SubmapPose* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubmapPose& from);
  void MergeFrom(const SubmapPose& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubmapPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.mapping.proto.SubmapId submap_id = 1;
  bool has_submap_id() const;
  void clear_submap_id();
  static const int kSubmapIdFieldNumber = 1;
  const ::ist_slam::mapping::proto::SubmapId& submap_id() const;
  ::ist_slam::mapping::proto::SubmapId* mutable_submap_id();
  ::ist_slam::mapping::proto::SubmapId* release_submap_id();
  void set_allocated_submap_id(::ist_slam::mapping::proto::SubmapId* submap_id);

  // .ist_slam.transform.proto.Rigid3d global_pose = 3;
  bool has_global_pose() const;
  void clear_global_pose();
  static const int kGlobalPoseFieldNumber = 3;
  const ::ist_slam::transform::proto::Rigid3d& global_pose() const;
  ::ist_slam::transform::proto::Rigid3d* mutable_global_pose();
  ::ist_slam::transform::proto::Rigid3d* release_global_pose();
  void set_allocated_global_pose(::ist_slam::transform::proto::Rigid3d* global_pose);

  // int32 submap_version = 2;
  void clear_submap_version();
  static const int kSubmapVersionFieldNumber = 2;
  ::google::protobuf::int32 submap_version() const;
  void set_submap_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.SubmapPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::mapping::proto::SubmapId* submap_id_;
  ::ist_slam::transform::proto::Rigid3d* global_pose_;
  ::google::protobuf::int32 submap_version_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAllSubmapPosesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetAllSubmapPosesResponse) */ {
 public:
  GetAllSubmapPosesResponse();
  virtual ~GetAllSubmapPosesResponse();

  GetAllSubmapPosesResponse(const GetAllSubmapPosesResponse& from);

  inline GetAllSubmapPosesResponse& operator=(const GetAllSubmapPosesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAllSubmapPosesResponse(GetAllSubmapPosesResponse&& from) noexcept
    : GetAllSubmapPosesResponse() {
    *this = ::std::move(from);
  }

  inline GetAllSubmapPosesResponse& operator=(GetAllSubmapPosesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllSubmapPosesResponse& default_instance();

  static inline const GetAllSubmapPosesResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllSubmapPosesResponse*>(
               &_GetAllSubmapPosesResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(GetAllSubmapPosesResponse* other);
  friend void swap(GetAllSubmapPosesResponse& a, GetAllSubmapPosesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAllSubmapPosesResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAllSubmapPosesResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAllSubmapPosesResponse& from);
  void MergeFrom(const GetAllSubmapPosesResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAllSubmapPosesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ist_slam.cloud.proto.SubmapPose submap_poses = 1;
  int submap_poses_size() const;
  void clear_submap_poses();
  static const int kSubmapPosesFieldNumber = 1;
  const ::ist_slam::cloud::proto::SubmapPose& submap_poses(int index) const;
  ::ist_slam::cloud::proto::SubmapPose* mutable_submap_poses(int index);
  ::ist_slam::cloud::proto::SubmapPose* add_submap_poses();
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SubmapPose >*
      mutable_submap_poses();
  const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SubmapPose >&
      submap_poses() const;

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetAllSubmapPosesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SubmapPose > submap_poses_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLocalToGlobalTransformRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetLocalToGlobalTransformRequest) */ {
 public:
  GetLocalToGlobalTransformRequest();
  virtual ~GetLocalToGlobalTransformRequest();

  GetLocalToGlobalTransformRequest(const GetLocalToGlobalTransformRequest& from);

  inline GetLocalToGlobalTransformRequest& operator=(const GetLocalToGlobalTransformRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLocalToGlobalTransformRequest(GetLocalToGlobalTransformRequest&& from) noexcept
    : GetLocalToGlobalTransformRequest() {
    *this = ::std::move(from);
  }

  inline GetLocalToGlobalTransformRequest& operator=(GetLocalToGlobalTransformRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLocalToGlobalTransformRequest& default_instance();

  static inline const GetLocalToGlobalTransformRequest* internal_default_instance() {
    return reinterpret_cast<const GetLocalToGlobalTransformRequest*>(
               &_GetLocalToGlobalTransformRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(GetLocalToGlobalTransformRequest* other);
  friend void swap(GetLocalToGlobalTransformRequest& a, GetLocalToGlobalTransformRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLocalToGlobalTransformRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLocalToGlobalTransformRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLocalToGlobalTransformRequest& from);
  void MergeFrom(const GetLocalToGlobalTransformRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLocalToGlobalTransformRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetLocalToGlobalTransformRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLocalToGlobalTransformResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetLocalToGlobalTransformResponse) */ {
 public:
  GetLocalToGlobalTransformResponse();
  virtual ~GetLocalToGlobalTransformResponse();

  GetLocalToGlobalTransformResponse(const GetLocalToGlobalTransformResponse& from);

  inline GetLocalToGlobalTransformResponse& operator=(const GetLocalToGlobalTransformResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLocalToGlobalTransformResponse(GetLocalToGlobalTransformResponse&& from) noexcept
    : GetLocalToGlobalTransformResponse() {
    *this = ::std::move(from);
  }

  inline GetLocalToGlobalTransformResponse& operator=(GetLocalToGlobalTransformResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLocalToGlobalTransformResponse& default_instance();

  static inline const GetLocalToGlobalTransformResponse* internal_default_instance() {
    return reinterpret_cast<const GetLocalToGlobalTransformResponse*>(
               &_GetLocalToGlobalTransformResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(GetLocalToGlobalTransformResponse* other);
  friend void swap(GetLocalToGlobalTransformResponse& a, GetLocalToGlobalTransformResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLocalToGlobalTransformResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLocalToGlobalTransformResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLocalToGlobalTransformResponse& from);
  void MergeFrom(const GetLocalToGlobalTransformResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLocalToGlobalTransformResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.transform.proto.Rigid3d local_to_global = 1;
  bool has_local_to_global() const;
  void clear_local_to_global();
  static const int kLocalToGlobalFieldNumber = 1;
  const ::ist_slam::transform::proto::Rigid3d& local_to_global() const;
  ::ist_slam::transform::proto::Rigid3d* mutable_local_to_global();
  ::ist_slam::transform::proto::Rigid3d* release_local_to_global();
  void set_allocated_local_to_global(::ist_slam::transform::proto::Rigid3d* local_to_global);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetLocalToGlobalTransformResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ist_slam::transform::proto::Rigid3d* local_to_global_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetConstraintsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.GetConstraintsResponse) */ {
 public:
  GetConstraintsResponse();
  virtual ~GetConstraintsResponse();

  GetConstraintsResponse(const GetConstraintsResponse& from);

  inline GetConstraintsResponse& operator=(const GetConstraintsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetConstraintsResponse(GetConstraintsResponse&& from) noexcept
    : GetConstraintsResponse() {
    *this = ::std::move(from);
  }

  inline GetConstraintsResponse& operator=(GetConstraintsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConstraintsResponse& default_instance();

  static inline const GetConstraintsResponse* internal_default_instance() {
    return reinterpret_cast<const GetConstraintsResponse*>(
               &_GetConstraintsResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(GetConstraintsResponse* other);
  friend void swap(GetConstraintsResponse& a, GetConstraintsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetConstraintsResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetConstraintsResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetConstraintsResponse& from);
  void MergeFrom(const GetConstraintsResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetConstraintsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ist_slam.mapping.proto.PoseGraph.Constraint constraints = 1;
  int constraints_size() const;
  void clear_constraints();
  static const int kConstraintsFieldNumber = 1;
  const ::ist_slam::mapping::proto::PoseGraph_Constraint& constraints(int index) const;
  ::ist_slam::mapping::proto::PoseGraph_Constraint* mutable_constraints(int index);
  ::ist_slam::mapping::proto::PoseGraph_Constraint* add_constraints();
  ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_Constraint >*
      mutable_constraints();
  const ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_Constraint >&
      constraints() const;

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.GetConstraintsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_Constraint > constraints_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.WriteStateResponse) */ {
 public:
  WriteStateResponse();
  virtual ~WriteStateResponse();

  WriteStateResponse(const WriteStateResponse& from);

  inline WriteStateResponse& operator=(const WriteStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStateResponse(WriteStateResponse&& from) noexcept
    : WriteStateResponse() {
    *this = ::std::move(from);
  }

  inline WriteStateResponse& operator=(WriteStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStateResponse& default_instance();

  enum StateChunkCase {
    kHeader = 1,
    kSerializedData = 2,
    STATE_CHUNK_NOT_SET = 0,
  };

  static inline const WriteStateResponse* internal_default_instance() {
    return reinterpret_cast<const WriteStateResponse*>(
               &_WriteStateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(WriteStateResponse* other);
  friend void swap(WriteStateResponse& a, WriteStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  WriteStateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WriteStateResponse& from);
  void MergeFrom(const WriteStateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WriteStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ist_slam.mapping.proto.SerializationHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ist_slam::mapping::proto::SerializationHeader& header() const;
  ::ist_slam::mapping::proto::SerializationHeader* mutable_header();
  ::ist_slam::mapping::proto::SerializationHeader* release_header();
  void set_allocated_header(::ist_slam::mapping::proto::SerializationHeader* header);

  // .ist_slam.mapping.proto.SerializedData serialized_data = 2;
  bool has_serialized_data() const;
  void clear_serialized_data();
  static const int kSerializedDataFieldNumber = 2;
  const ::ist_slam::mapping::proto::SerializedData& serialized_data() const;
  ::ist_slam::mapping::proto::SerializedData* mutable_serialized_data();
  ::ist_slam::mapping::proto::SerializedData* release_serialized_data();
  void set_allocated_serialized_data(::ist_slam::mapping::proto::SerializedData* serialized_data);

  StateChunkCase state_chunk_case() const;
  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.WriteStateResponse)
 private:
  void set_has_header();
  void set_has_serialized_data();

  inline bool has_state_chunk() const;
  void clear_state_chunk();
  inline void clear_has_state_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StateChunkUnion {
    StateChunkUnion() {}
    ::ist_slam::mapping::proto::SerializationHeader* header_;
    ::ist_slam::mapping::proto::SerializedData* serialized_data_;
  } state_chunk_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStateToFileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.WriteStateToFileRequest) */ {
 public:
  WriteStateToFileRequest();
  virtual ~WriteStateToFileRequest();

  WriteStateToFileRequest(const WriteStateToFileRequest& from);

  inline WriteStateToFileRequest& operator=(const WriteStateToFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStateToFileRequest(WriteStateToFileRequest&& from) noexcept
    : WriteStateToFileRequest() {
    *this = ::std::move(from);
  }

  inline WriteStateToFileRequest& operator=(WriteStateToFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStateToFileRequest& default_instance();

  static inline const WriteStateToFileRequest* internal_default_instance() {
    return reinterpret_cast<const WriteStateToFileRequest*>(
               &_WriteStateToFileRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(WriteStateToFileRequest* other);
  friend void swap(WriteStateToFileRequest& a, WriteStateToFileRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStateToFileRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  WriteStateToFileRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WriteStateToFileRequest& from);
  void MergeFrom(const WriteStateToFileRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WriteStateToFileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filename = 1;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_filename(::std::string&& value);
  #endif
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.WriteStateToFileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteStateToFileResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.WriteStateToFileResponse) */ {
 public:
  WriteStateToFileResponse();
  virtual ~WriteStateToFileResponse();

  WriteStateToFileResponse(const WriteStateToFileResponse& from);

  inline WriteStateToFileResponse& operator=(const WriteStateToFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteStateToFileResponse(WriteStateToFileResponse&& from) noexcept
    : WriteStateToFileResponse() {
    *this = ::std::move(from);
  }

  inline WriteStateToFileResponse& operator=(WriteStateToFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteStateToFileResponse& default_instance();

  static inline const WriteStateToFileResponse* internal_default_instance() {
    return reinterpret_cast<const WriteStateToFileResponse*>(
               &_WriteStateToFileResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(WriteStateToFileResponse* other);
  friend void swap(WriteStateToFileResponse& a, WriteStateToFileResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteStateToFileResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  WriteStateToFileResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WriteStateToFileResponse& from);
  void MergeFrom(const WriteStateToFileResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WriteStateToFileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.WriteStateToFileResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool success_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFinishedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.IsTrajectoryFinishedRequest) */ {
 public:
  IsTrajectoryFinishedRequest();
  virtual ~IsTrajectoryFinishedRequest();

  IsTrajectoryFinishedRequest(const IsTrajectoryFinishedRequest& from);

  inline IsTrajectoryFinishedRequest& operator=(const IsTrajectoryFinishedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFinishedRequest(IsTrajectoryFinishedRequest&& from) noexcept
    : IsTrajectoryFinishedRequest() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFinishedRequest& operator=(IsTrajectoryFinishedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFinishedRequest& default_instance();

  static inline const IsTrajectoryFinishedRequest* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFinishedRequest*>(
               &_IsTrajectoryFinishedRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(IsTrajectoryFinishedRequest* other);
  friend void swap(IsTrajectoryFinishedRequest& a, IsTrajectoryFinishedRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFinishedRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IsTrajectoryFinishedRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IsTrajectoryFinishedRequest& from);
  void MergeFrom(const IsTrajectoryFinishedRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IsTrajectoryFinishedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.IsTrajectoryFinishedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFinishedResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.IsTrajectoryFinishedResponse) */ {
 public:
  IsTrajectoryFinishedResponse();
  virtual ~IsTrajectoryFinishedResponse();

  IsTrajectoryFinishedResponse(const IsTrajectoryFinishedResponse& from);

  inline IsTrajectoryFinishedResponse& operator=(const IsTrajectoryFinishedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFinishedResponse(IsTrajectoryFinishedResponse&& from) noexcept
    : IsTrajectoryFinishedResponse() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFinishedResponse& operator=(IsTrajectoryFinishedResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFinishedResponse& default_instance();

  static inline const IsTrajectoryFinishedResponse* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFinishedResponse*>(
               &_IsTrajectoryFinishedResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(IsTrajectoryFinishedResponse* other);
  friend void swap(IsTrajectoryFinishedResponse& a, IsTrajectoryFinishedResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFinishedResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IsTrajectoryFinishedResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IsTrajectoryFinishedResponse& from);
  void MergeFrom(const IsTrajectoryFinishedResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IsTrajectoryFinishedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_finished = 1;
  void clear_is_finished();
  static const int kIsFinishedFieldNumber = 1;
  bool is_finished() const;
  void set_is_finished(bool value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.IsTrajectoryFinishedResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_finished_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFrozenRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.IsTrajectoryFrozenRequest) */ {
 public:
  IsTrajectoryFrozenRequest();
  virtual ~IsTrajectoryFrozenRequest();

  IsTrajectoryFrozenRequest(const IsTrajectoryFrozenRequest& from);

  inline IsTrajectoryFrozenRequest& operator=(const IsTrajectoryFrozenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFrozenRequest(IsTrajectoryFrozenRequest&& from) noexcept
    : IsTrajectoryFrozenRequest() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFrozenRequest& operator=(IsTrajectoryFrozenRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFrozenRequest& default_instance();

  static inline const IsTrajectoryFrozenRequest* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFrozenRequest*>(
               &_IsTrajectoryFrozenRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(IsTrajectoryFrozenRequest* other);
  friend void swap(IsTrajectoryFrozenRequest& a, IsTrajectoryFrozenRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFrozenRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IsTrajectoryFrozenRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IsTrajectoryFrozenRequest& from);
  void MergeFrom(const IsTrajectoryFrozenRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IsTrajectoryFrozenRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 trajectory_id = 1;
  void clear_trajectory_id();
  static const int kTrajectoryIdFieldNumber = 1;
  ::google::protobuf::int32 trajectory_id() const;
  void set_trajectory_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.IsTrajectoryFrozenRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 trajectory_id_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsTrajectoryFrozenResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ist_slam.cloud.proto.IsTrajectoryFrozenResponse) */ {
 public:
  IsTrajectoryFrozenResponse();
  virtual ~IsTrajectoryFrozenResponse();

  IsTrajectoryFrozenResponse(const IsTrajectoryFrozenResponse& from);

  inline IsTrajectoryFrozenResponse& operator=(const IsTrajectoryFrozenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsTrajectoryFrozenResponse(IsTrajectoryFrozenResponse&& from) noexcept
    : IsTrajectoryFrozenResponse() {
    *this = ::std::move(from);
  }

  inline IsTrajectoryFrozenResponse& operator=(IsTrajectoryFrozenResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsTrajectoryFrozenResponse& default_instance();

  static inline const IsTrajectoryFrozenResponse* internal_default_instance() {
    return reinterpret_cast<const IsTrajectoryFrozenResponse*>(
               &_IsTrajectoryFrozenResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(IsTrajectoryFrozenResponse* other);
  friend void swap(IsTrajectoryFrozenResponse& a, IsTrajectoryFrozenResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsTrajectoryFrozenResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IsTrajectoryFrozenResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IsTrajectoryFrozenResponse& from);
  void MergeFrom(const IsTrajectoryFrozenResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IsTrajectoryFrozenResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool is_frozen = 1;
  void clear_is_frozen();
  static const int kIsFrozenFieldNumber = 1;
  bool is_frozen() const;
  void set_is_frozen(bool value);

  // @@protoc_insertion_point(class_scope:ist_slam.cloud.proto.IsTrajectoryFrozenResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool is_frozen_;
  mutable int _cached_size_;
  friend struct protobuf_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SensorId

// string id = 1;
inline void SensorId::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorId::id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorId.id)
  return id_.GetNoArena();
}
inline void SensorId::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.SensorId.id)
}
#if LANG_CXX11
inline void SensorId::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.SensorId.id)
}
#endif
inline void SensorId::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.SensorId.id)
}
inline void SensorId::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.SensorId.id)
}
inline ::std::string* SensorId::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorId.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorId::release_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorId.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorId::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorId.id)
}

// .ist_slam.cloud.proto.SensorType type = 2;
inline void SensorId::clear_type() {
  type_ = 0;
}
inline ::ist_slam::cloud::proto::SensorType SensorId::type() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorId.type)
  return static_cast< ::ist_slam::cloud::proto::SensorType >(type_);
}
inline void SensorId::set_type(::ist_slam::cloud::proto::SensorType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.SensorId.type)
}

// -------------------------------------------------------------------

// AddTrajectoryRequest

// repeated .ist_slam.cloud.proto.SensorId expected_sensor_ids = 3;
inline int AddTrajectoryRequest::expected_sensor_ids_size() const {
  return expected_sensor_ids_.size();
}
inline void AddTrajectoryRequest::clear_expected_sensor_ids() {
  expected_sensor_ids_.Clear();
}
inline const ::ist_slam::cloud::proto::SensorId& AddTrajectoryRequest::expected_sensor_ids(int index) const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Get(index);
}
inline ::ist_slam::cloud::proto::SensorId* AddTrajectoryRequest::mutable_expected_sensor_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Mutable(index);
}
inline ::ist_slam::cloud::proto::SensorId* AddTrajectoryRequest::add_expected_sensor_ids() {
  // @@protoc_insertion_point(field_add:ist_slam.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorId >*
AddTrajectoryRequest::mutable_expected_sensor_ids() {
  // @@protoc_insertion_point(field_mutable_list:ist_slam.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return &expected_sensor_ids_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorId >&
AddTrajectoryRequest::expected_sensor_ids() const {
  // @@protoc_insertion_point(field_list:ist_slam.cloud.proto.AddTrajectoryRequest.expected_sensor_ids)
  return expected_sensor_ids_;
}

// .ist_slam.mapping.proto.TrajectoryBuilderOptions trajectory_builder_options = 2;
inline bool AddTrajectoryRequest::has_trajectory_builder_options() const {
  return this != internal_default_instance() && trajectory_builder_options_ != NULL;
}
inline void AddTrajectoryRequest::clear_trajectory_builder_options() {
  if (GetArenaNoVirtual() == NULL && trajectory_builder_options_ != NULL) delete trajectory_builder_options_;
  trajectory_builder_options_ = NULL;
}
inline const ::ist_slam::mapping::proto::TrajectoryBuilderOptions& AddTrajectoryRequest::trajectory_builder_options() const {
  const ::ist_slam::mapping::proto::TrajectoryBuilderOptions* p = trajectory_builder_options_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::TrajectoryBuilderOptions*>(
      &::ist_slam::mapping::proto::_TrajectoryBuilderOptions_default_instance_);
}
inline ::ist_slam::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::mutable_trajectory_builder_options() {
  
  if (trajectory_builder_options_ == NULL) {
    trajectory_builder_options_ = new ::ist_slam::mapping::proto::TrajectoryBuilderOptions;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  return trajectory_builder_options_;
}
inline ::ist_slam::mapping::proto::TrajectoryBuilderOptions* AddTrajectoryRequest::release_trajectory_builder_options() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
  
  ::ist_slam::mapping::proto::TrajectoryBuilderOptions* temp = trajectory_builder_options_;
  trajectory_builder_options_ = NULL;
  return temp;
}
inline void AddTrajectoryRequest::set_allocated_trajectory_builder_options(::ist_slam::mapping::proto::TrajectoryBuilderOptions* trajectory_builder_options) {
  delete trajectory_builder_options_;
  trajectory_builder_options_ = trajectory_builder_options;
  if (trajectory_builder_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddTrajectoryRequest.trajectory_builder_options)
}

// string client_id = 4;
inline void AddTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
  return client_id_.GetNoArena();
}
inline void AddTrajectoryRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
}
#if LANG_CXX11
inline void AddTrajectoryRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
}
#endif
inline void AddTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
}
inline void AddTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
}
inline ::std::string* AddTrajectoryRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddTrajectoryRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// SensorMetadata

// int32 trajectory_id = 1;
inline void SensorMetadata::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 SensorMetadata::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorMetadata.trajectory_id)
  return trajectory_id_;
}
inline void SensorMetadata::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.SensorMetadata.trajectory_id)
}

// string sensor_id = 2;
inline void SensorMetadata::clear_sensor_id() {
  sensor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorMetadata::sensor_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorMetadata.sensor_id)
  return sensor_id_.GetNoArena();
}
inline void SensorMetadata::set_sensor_id(const ::std::string& value) {
  
  sensor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.SensorMetadata.sensor_id)
}
#if LANG_CXX11
inline void SensorMetadata::set_sensor_id(::std::string&& value) {
  
  sensor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.SensorMetadata.sensor_id)
}
#endif
inline void SensorMetadata::set_sensor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sensor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.SensorMetadata.sensor_id)
}
inline void SensorMetadata::set_sensor_id(const char* value, size_t size) {
  
  sensor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.SensorMetadata.sensor_id)
}
inline ::std::string* SensorMetadata::mutable_sensor_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorMetadata.sensor_id)
  return sensor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorMetadata::release_sensor_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorMetadata.sensor_id)
  
  return sensor_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorMetadata::set_allocated_sensor_id(::std::string* sensor_id) {
  if (sensor_id != NULL) {
    
  } else {
    
  }
  sensor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorMetadata.sensor_id)
}

// string client_id = 3;
inline void SensorMetadata::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorMetadata::client_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorMetadata.client_id)
  return client_id_.GetNoArena();
}
inline void SensorMetadata::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.SensorMetadata.client_id)
}
#if LANG_CXX11
inline void SensorMetadata::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.SensorMetadata.client_id)
}
#endif
inline void SensorMetadata::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.SensorMetadata.client_id)
}
inline void SensorMetadata::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.SensorMetadata.client_id)
}
inline ::std::string* SensorMetadata::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorMetadata.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorMetadata::release_client_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorMetadata.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorMetadata::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorMetadata.client_id)
}

// -------------------------------------------------------------------

// SensorData

// .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool SensorData::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void SensorData::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) delete sensor_metadata_;
  sensor_metadata_ = NULL;
}
inline const ::ist_slam::cloud::proto::SensorMetadata& SensorData::sensor_metadata() const {
  const ::ist_slam::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::SensorMetadata*>(
      &::ist_slam::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::ist_slam::cloud::proto::SensorMetadata* SensorData::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    sensor_metadata_ = new ::ist_slam::cloud::proto::SensorMetadata;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.sensor_metadata)
  return sensor_metadata_;
}
inline ::ist_slam::cloud::proto::SensorMetadata* SensorData::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.sensor_metadata)
  
  ::ist_slam::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata) {
  delete sensor_metadata_;
  sensor_metadata_ = sensor_metadata;
  if (sensor_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.sensor_metadata)
}

// .ist_slam.sensor.proto.OdometryData odometry_data = 2;
inline bool SensorData::has_odometry_data() const {
  return sensor_data_case() == kOdometryData;
}
inline void SensorData::set_has_odometry_data() {
  _oneof_case_[0] = kOdometryData;
}
inline void SensorData::clear_odometry_data() {
  if (has_odometry_data()) {
    delete sensor_data_.odometry_data_;
    clear_has_sensor_data();
  }
}
inline  const ::ist_slam::sensor::proto::OdometryData& SensorData::odometry_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.odometry_data)
  return has_odometry_data()
      ? *sensor_data_.odometry_data_
      : ::ist_slam::sensor::proto::OdometryData::default_instance();
}
inline ::ist_slam::sensor::proto::OdometryData* SensorData::mutable_odometry_data() {
  if (!has_odometry_data()) {
    clear_sensor_data();
    set_has_odometry_data();
    sensor_data_.odometry_data_ = new ::ist_slam::sensor::proto::OdometryData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.odometry_data)
  return sensor_data_.odometry_data_;
}
inline ::ist_slam::sensor::proto::OdometryData* SensorData::release_odometry_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.odometry_data)
  if (has_odometry_data()) {
    clear_has_sensor_data();
    ::ist_slam::sensor::proto::OdometryData* temp = sensor_data_.odometry_data_;
    sensor_data_.odometry_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SensorData::set_allocated_odometry_data(::ist_slam::sensor::proto::OdometryData* odometry_data) {
  clear_sensor_data();
  if (odometry_data) {
    set_has_odometry_data();
    sensor_data_.odometry_data_ = odometry_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.odometry_data)
}

// .ist_slam.sensor.proto.ImuData imu_data = 3;
inline bool SensorData::has_imu_data() const {
  return sensor_data_case() == kImuData;
}
inline void SensorData::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline void SensorData::clear_imu_data() {
  if (has_imu_data()) {
    delete sensor_data_.imu_data_;
    clear_has_sensor_data();
  }
}
inline  const ::ist_slam::sensor::proto::ImuData& SensorData::imu_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.imu_data)
  return has_imu_data()
      ? *sensor_data_.imu_data_
      : ::ist_slam::sensor::proto::ImuData::default_instance();
}
inline ::ist_slam::sensor::proto::ImuData* SensorData::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_sensor_data();
    set_has_imu_data();
    sensor_data_.imu_data_ = new ::ist_slam::sensor::proto::ImuData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.imu_data)
  return sensor_data_.imu_data_;
}
inline ::ist_slam::sensor::proto::ImuData* SensorData::release_imu_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.imu_data)
  if (has_imu_data()) {
    clear_has_sensor_data();
    ::ist_slam::sensor::proto::ImuData* temp = sensor_data_.imu_data_;
    sensor_data_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SensorData::set_allocated_imu_data(::ist_slam::sensor::proto::ImuData* imu_data) {
  clear_sensor_data();
  if (imu_data) {
    set_has_imu_data();
    sensor_data_.imu_data_ = imu_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.imu_data)
}

// .ist_slam.sensor.proto.TimedPointCloudData timed_point_cloud_data = 4;
inline bool SensorData::has_timed_point_cloud_data() const {
  return sensor_data_case() == kTimedPointCloudData;
}
inline void SensorData::set_has_timed_point_cloud_data() {
  _oneof_case_[0] = kTimedPointCloudData;
}
inline void SensorData::clear_timed_point_cloud_data() {
  if (has_timed_point_cloud_data()) {
    delete sensor_data_.timed_point_cloud_data_;
    clear_has_sensor_data();
  }
}
inline  const ::ist_slam::sensor::proto::TimedPointCloudData& SensorData::timed_point_cloud_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.timed_point_cloud_data)
  return has_timed_point_cloud_data()
      ? *sensor_data_.timed_point_cloud_data_
      : ::ist_slam::sensor::proto::TimedPointCloudData::default_instance();
}
inline ::ist_slam::sensor::proto::TimedPointCloudData* SensorData::mutable_timed_point_cloud_data() {
  if (!has_timed_point_cloud_data()) {
    clear_sensor_data();
    set_has_timed_point_cloud_data();
    sensor_data_.timed_point_cloud_data_ = new ::ist_slam::sensor::proto::TimedPointCloudData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.timed_point_cloud_data)
  return sensor_data_.timed_point_cloud_data_;
}
inline ::ist_slam::sensor::proto::TimedPointCloudData* SensorData::release_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.timed_point_cloud_data)
  if (has_timed_point_cloud_data()) {
    clear_has_sensor_data();
    ::ist_slam::sensor::proto::TimedPointCloudData* temp = sensor_data_.timed_point_cloud_data_;
    sensor_data_.timed_point_cloud_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SensorData::set_allocated_timed_point_cloud_data(::ist_slam::sensor::proto::TimedPointCloudData* timed_point_cloud_data) {
  clear_sensor_data();
  if (timed_point_cloud_data) {
    set_has_timed_point_cloud_data();
    sensor_data_.timed_point_cloud_data_ = timed_point_cloud_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.timed_point_cloud_data)
}

// .ist_slam.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 5;
inline bool SensorData::has_fixed_frame_pose_data() const {
  return sensor_data_case() == kFixedFramePoseData;
}
inline void SensorData::set_has_fixed_frame_pose_data() {
  _oneof_case_[0] = kFixedFramePoseData;
}
inline void SensorData::clear_fixed_frame_pose_data() {
  if (has_fixed_frame_pose_data()) {
    delete sensor_data_.fixed_frame_pose_data_;
    clear_has_sensor_data();
  }
}
inline  const ::ist_slam::sensor::proto::FixedFramePoseData& SensorData::fixed_frame_pose_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.fixed_frame_pose_data)
  return has_fixed_frame_pose_data()
      ? *sensor_data_.fixed_frame_pose_data_
      : ::ist_slam::sensor::proto::FixedFramePoseData::default_instance();
}
inline ::ist_slam::sensor::proto::FixedFramePoseData* SensorData::mutable_fixed_frame_pose_data() {
  if (!has_fixed_frame_pose_data()) {
    clear_sensor_data();
    set_has_fixed_frame_pose_data();
    sensor_data_.fixed_frame_pose_data_ = new ::ist_slam::sensor::proto::FixedFramePoseData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.fixed_frame_pose_data)
  return sensor_data_.fixed_frame_pose_data_;
}
inline ::ist_slam::sensor::proto::FixedFramePoseData* SensorData::release_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.fixed_frame_pose_data)
  if (has_fixed_frame_pose_data()) {
    clear_has_sensor_data();
    ::ist_slam::sensor::proto::FixedFramePoseData* temp = sensor_data_.fixed_frame_pose_data_;
    sensor_data_.fixed_frame_pose_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SensorData::set_allocated_fixed_frame_pose_data(::ist_slam::sensor::proto::FixedFramePoseData* fixed_frame_pose_data) {
  clear_sensor_data();
  if (fixed_frame_pose_data) {
    set_has_fixed_frame_pose_data();
    sensor_data_.fixed_frame_pose_data_ = fixed_frame_pose_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.fixed_frame_pose_data)
}

// .ist_slam.sensor.proto.LandmarkData landmark_data = 6;
inline bool SensorData::has_landmark_data() const {
  return sensor_data_case() == kLandmarkData;
}
inline void SensorData::set_has_landmark_data() {
  _oneof_case_[0] = kLandmarkData;
}
inline void SensorData::clear_landmark_data() {
  if (has_landmark_data()) {
    delete sensor_data_.landmark_data_;
    clear_has_sensor_data();
  }
}
inline  const ::ist_slam::sensor::proto::LandmarkData& SensorData::landmark_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.landmark_data)
  return has_landmark_data()
      ? *sensor_data_.landmark_data_
      : ::ist_slam::sensor::proto::LandmarkData::default_instance();
}
inline ::ist_slam::sensor::proto::LandmarkData* SensorData::mutable_landmark_data() {
  if (!has_landmark_data()) {
    clear_sensor_data();
    set_has_landmark_data();
    sensor_data_.landmark_data_ = new ::ist_slam::sensor::proto::LandmarkData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.landmark_data)
  return sensor_data_.landmark_data_;
}
inline ::ist_slam::sensor::proto::LandmarkData* SensorData::release_landmark_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.landmark_data)
  if (has_landmark_data()) {
    clear_has_sensor_data();
    ::ist_slam::sensor::proto::LandmarkData* temp = sensor_data_.landmark_data_;
    sensor_data_.landmark_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SensorData::set_allocated_landmark_data(::ist_slam::sensor::proto::LandmarkData* landmark_data) {
  clear_sensor_data();
  if (landmark_data) {
    set_has_landmark_data();
    sensor_data_.landmark_data_ = landmark_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.landmark_data)
}

// .ist_slam.mapping.proto.LocalSlamResultData local_slam_result_data = 7;
inline bool SensorData::has_local_slam_result_data() const {
  return sensor_data_case() == kLocalSlamResultData;
}
inline void SensorData::set_has_local_slam_result_data() {
  _oneof_case_[0] = kLocalSlamResultData;
}
inline void SensorData::clear_local_slam_result_data() {
  if (has_local_slam_result_data()) {
    delete sensor_data_.local_slam_result_data_;
    clear_has_sensor_data();
  }
}
inline  const ::ist_slam::mapping::proto::LocalSlamResultData& SensorData::local_slam_result_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SensorData.local_slam_result_data)
  return has_local_slam_result_data()
      ? *sensor_data_.local_slam_result_data_
      : ::ist_slam::mapping::proto::LocalSlamResultData::default_instance();
}
inline ::ist_slam::mapping::proto::LocalSlamResultData* SensorData::mutable_local_slam_result_data() {
  if (!has_local_slam_result_data()) {
    clear_sensor_data();
    set_has_local_slam_result_data();
    sensor_data_.local_slam_result_data_ = new ::ist_slam::mapping::proto::LocalSlamResultData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SensorData.local_slam_result_data)
  return sensor_data_.local_slam_result_data_;
}
inline ::ist_slam::mapping::proto::LocalSlamResultData* SensorData::release_local_slam_result_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SensorData.local_slam_result_data)
  if (has_local_slam_result_data()) {
    clear_has_sensor_data();
    ::ist_slam::mapping::proto::LocalSlamResultData* temp = sensor_data_.local_slam_result_data_;
    sensor_data_.local_slam_result_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void SensorData::set_allocated_local_slam_result_data(::ist_slam::mapping::proto::LocalSlamResultData* local_slam_result_data) {
  clear_sensor_data();
  if (local_slam_result_data) {
    set_has_local_slam_result_data();
    sensor_data_.local_slam_result_data_ = local_slam_result_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SensorData.local_slam_result_data)
}

inline bool SensorData::has_sensor_data() const {
  return sensor_data_case() != SENSOR_DATA_NOT_SET;
}
inline void SensorData::clear_has_sensor_data() {
  _oneof_case_[0] = SENSOR_DATA_NOT_SET;
}
inline SensorData::SensorDataCase SensorData::sensor_data_case() const {
  return SensorData::SensorDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddTrajectoryResponse

// int32 trajectory_id = 1;
inline void AddTrajectoryResponse::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 AddTrajectoryResponse::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddTrajectoryResponse.trajectory_id)
  return trajectory_id_;
}
inline void AddTrajectoryResponse::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.AddTrajectoryResponse.trajectory_id)
}

// -------------------------------------------------------------------

// AddSensorDataBatchRequest

// repeated .ist_slam.cloud.proto.SensorData sensor_data = 1;
inline int AddSensorDataBatchRequest::sensor_data_size() const {
  return sensor_data_.size();
}
inline void AddSensorDataBatchRequest::clear_sensor_data() {
  sensor_data_.Clear();
}
inline const ::ist_slam::cloud::proto::SensorData& AddSensorDataBatchRequest::sensor_data(int index) const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Get(index);
}
inline ::ist_slam::cloud::proto::SensorData* AddSensorDataBatchRequest::mutable_sensor_data(int index) {
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Mutable(index);
}
inline ::ist_slam::cloud::proto::SensorData* AddSensorDataBatchRequest::add_sensor_data() {
  // @@protoc_insertion_point(field_add:ist_slam.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorData >*
AddSensorDataBatchRequest::mutable_sensor_data() {
  // @@protoc_insertion_point(field_mutable_list:ist_slam.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return &sensor_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SensorData >&
AddSensorDataBatchRequest::sensor_data() const {
  // @@protoc_insertion_point(field_list:ist_slam.cloud.proto.AddSensorDataBatchRequest.sensor_data)
  return sensor_data_;
}

// -------------------------------------------------------------------

// AddOdometryDataRequest

// .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddOdometryDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddOdometryDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) delete sensor_metadata_;
  sensor_metadata_ = NULL;
}
inline const ::ist_slam::cloud::proto::SensorMetadata& AddOdometryDataRequest::sensor_metadata() const {
  const ::ist_slam::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::SensorMetadata*>(
      &::ist_slam::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddOdometryDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    sensor_metadata_ = new ::ist_slam::cloud::proto::SensorMetadata;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddOdometryDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddOdometryDataRequest.sensor_metadata)
  
  ::ist_slam::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline void AddOdometryDataRequest::set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata) {
  delete sensor_metadata_;
  sensor_metadata_ = sensor_metadata;
  if (sensor_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddOdometryDataRequest.sensor_metadata)
}

// .ist_slam.sensor.proto.OdometryData odometry_data = 2;
inline bool AddOdometryDataRequest::has_odometry_data() const {
  return this != internal_default_instance() && odometry_data_ != NULL;
}
inline void AddOdometryDataRequest::clear_odometry_data() {
  if (GetArenaNoVirtual() == NULL && odometry_data_ != NULL) delete odometry_data_;
  odometry_data_ = NULL;
}
inline const ::ist_slam::sensor::proto::OdometryData& AddOdometryDataRequest::odometry_data() const {
  const ::ist_slam::sensor::proto::OdometryData* p = odometry_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddOdometryDataRequest.odometry_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::sensor::proto::OdometryData*>(
      &::ist_slam::sensor::proto::_OdometryData_default_instance_);
}
inline ::ist_slam::sensor::proto::OdometryData* AddOdometryDataRequest::mutable_odometry_data() {
  
  if (odometry_data_ == NULL) {
    odometry_data_ = new ::ist_slam::sensor::proto::OdometryData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddOdometryDataRequest.odometry_data)
  return odometry_data_;
}
inline ::ist_slam::sensor::proto::OdometryData* AddOdometryDataRequest::release_odometry_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddOdometryDataRequest.odometry_data)
  
  ::ist_slam::sensor::proto::OdometryData* temp = odometry_data_;
  odometry_data_ = NULL;
  return temp;
}
inline void AddOdometryDataRequest::set_allocated_odometry_data(::ist_slam::sensor::proto::OdometryData* odometry_data) {
  delete odometry_data_;
  odometry_data_ = odometry_data;
  if (odometry_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddOdometryDataRequest.odometry_data)
}

// -------------------------------------------------------------------

// AddImuDataRequest

// .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddImuDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddImuDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) delete sensor_metadata_;
  sensor_metadata_ = NULL;
}
inline const ::ist_slam::cloud::proto::SensorMetadata& AddImuDataRequest::sensor_metadata() const {
  const ::ist_slam::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddImuDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::SensorMetadata*>(
      &::ist_slam::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddImuDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    sensor_metadata_ = new ::ist_slam::cloud::proto::SensorMetadata;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddImuDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddImuDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddImuDataRequest.sensor_metadata)
  
  ::ist_slam::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline void AddImuDataRequest::set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata) {
  delete sensor_metadata_;
  sensor_metadata_ = sensor_metadata;
  if (sensor_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddImuDataRequest.sensor_metadata)
}

// .ist_slam.sensor.proto.ImuData imu_data = 2;
inline bool AddImuDataRequest::has_imu_data() const {
  return this != internal_default_instance() && imu_data_ != NULL;
}
inline void AddImuDataRequest::clear_imu_data() {
  if (GetArenaNoVirtual() == NULL && imu_data_ != NULL) delete imu_data_;
  imu_data_ = NULL;
}
inline const ::ist_slam::sensor::proto::ImuData& AddImuDataRequest::imu_data() const {
  const ::ist_slam::sensor::proto::ImuData* p = imu_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddImuDataRequest.imu_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::sensor::proto::ImuData*>(
      &::ist_slam::sensor::proto::_ImuData_default_instance_);
}
inline ::ist_slam::sensor::proto::ImuData* AddImuDataRequest::mutable_imu_data() {
  
  if (imu_data_ == NULL) {
    imu_data_ = new ::ist_slam::sensor::proto::ImuData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddImuDataRequest.imu_data)
  return imu_data_;
}
inline ::ist_slam::sensor::proto::ImuData* AddImuDataRequest::release_imu_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddImuDataRequest.imu_data)
  
  ::ist_slam::sensor::proto::ImuData* temp = imu_data_;
  imu_data_ = NULL;
  return temp;
}
inline void AddImuDataRequest::set_allocated_imu_data(::ist_slam::sensor::proto::ImuData* imu_data) {
  delete imu_data_;
  imu_data_ = imu_data;
  if (imu_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddImuDataRequest.imu_data)
}

// -------------------------------------------------------------------

// AddRangefinderDataRequest

// .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddRangefinderDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddRangefinderDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) delete sensor_metadata_;
  sensor_metadata_ = NULL;
}
inline const ::ist_slam::cloud::proto::SensorMetadata& AddRangefinderDataRequest::sensor_metadata() const {
  const ::ist_slam::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::SensorMetadata*>(
      &::ist_slam::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddRangefinderDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    sensor_metadata_ = new ::ist_slam::cloud::proto::SensorMetadata;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddRangefinderDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
  
  ::ist_slam::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline void AddRangefinderDataRequest::set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata) {
  delete sensor_metadata_;
  sensor_metadata_ = sensor_metadata;
  if (sensor_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddRangefinderDataRequest.sensor_metadata)
}

// .ist_slam.sensor.proto.TimedPointCloudData timed_point_cloud_data = 2;
inline bool AddRangefinderDataRequest::has_timed_point_cloud_data() const {
  return this != internal_default_instance() && timed_point_cloud_data_ != NULL;
}
inline void AddRangefinderDataRequest::clear_timed_point_cloud_data() {
  if (GetArenaNoVirtual() == NULL && timed_point_cloud_data_ != NULL) delete timed_point_cloud_data_;
  timed_point_cloud_data_ = NULL;
}
inline const ::ist_slam::sensor::proto::TimedPointCloudData& AddRangefinderDataRequest::timed_point_cloud_data() const {
  const ::ist_slam::sensor::proto::TimedPointCloudData* p = timed_point_cloud_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::sensor::proto::TimedPointCloudData*>(
      &::ist_slam::sensor::proto::_TimedPointCloudData_default_instance_);
}
inline ::ist_slam::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::mutable_timed_point_cloud_data() {
  
  if (timed_point_cloud_data_ == NULL) {
    timed_point_cloud_data_ = new ::ist_slam::sensor::proto::TimedPointCloudData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  return timed_point_cloud_data_;
}
inline ::ist_slam::sensor::proto::TimedPointCloudData* AddRangefinderDataRequest::release_timed_point_cloud_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
  
  ::ist_slam::sensor::proto::TimedPointCloudData* temp = timed_point_cloud_data_;
  timed_point_cloud_data_ = NULL;
  return temp;
}
inline void AddRangefinderDataRequest::set_allocated_timed_point_cloud_data(::ist_slam::sensor::proto::TimedPointCloudData* timed_point_cloud_data) {
  delete timed_point_cloud_data_;
  timed_point_cloud_data_ = timed_point_cloud_data;
  if (timed_point_cloud_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddRangefinderDataRequest.timed_point_cloud_data)
}

// -------------------------------------------------------------------

// AddFixedFramePoseDataRequest

// .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddFixedFramePoseDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddFixedFramePoseDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) delete sensor_metadata_;
  sensor_metadata_ = NULL;
}
inline const ::ist_slam::cloud::proto::SensorMetadata& AddFixedFramePoseDataRequest::sensor_metadata() const {
  const ::ist_slam::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::SensorMetadata*>(
      &::ist_slam::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    sensor_metadata_ = new ::ist_slam::cloud::proto::SensorMetadata;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddFixedFramePoseDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
  
  ::ist_slam::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline void AddFixedFramePoseDataRequest::set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata) {
  delete sensor_metadata_;
  sensor_metadata_ = sensor_metadata;
  if (sensor_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.sensor_metadata)
}

// .ist_slam.sensor.proto.FixedFramePoseData fixed_frame_pose_data = 2;
inline bool AddFixedFramePoseDataRequest::has_fixed_frame_pose_data() const {
  return this != internal_default_instance() && fixed_frame_pose_data_ != NULL;
}
inline void AddFixedFramePoseDataRequest::clear_fixed_frame_pose_data() {
  if (GetArenaNoVirtual() == NULL && fixed_frame_pose_data_ != NULL) delete fixed_frame_pose_data_;
  fixed_frame_pose_data_ = NULL;
}
inline const ::ist_slam::sensor::proto::FixedFramePoseData& AddFixedFramePoseDataRequest::fixed_frame_pose_data() const {
  const ::ist_slam::sensor::proto::FixedFramePoseData* p = fixed_frame_pose_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::sensor::proto::FixedFramePoseData*>(
      &::ist_slam::sensor::proto::_FixedFramePoseData_default_instance_);
}
inline ::ist_slam::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::mutable_fixed_frame_pose_data() {
  
  if (fixed_frame_pose_data_ == NULL) {
    fixed_frame_pose_data_ = new ::ist_slam::sensor::proto::FixedFramePoseData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  return fixed_frame_pose_data_;
}
inline ::ist_slam::sensor::proto::FixedFramePoseData* AddFixedFramePoseDataRequest::release_fixed_frame_pose_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
  
  ::ist_slam::sensor::proto::FixedFramePoseData* temp = fixed_frame_pose_data_;
  fixed_frame_pose_data_ = NULL;
  return temp;
}
inline void AddFixedFramePoseDataRequest::set_allocated_fixed_frame_pose_data(::ist_slam::sensor::proto::FixedFramePoseData* fixed_frame_pose_data) {
  delete fixed_frame_pose_data_;
  fixed_frame_pose_data_ = fixed_frame_pose_data;
  if (fixed_frame_pose_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddFixedFramePoseDataRequest.fixed_frame_pose_data)
}

// -------------------------------------------------------------------

// AddLandmarkDataRequest

// .ist_slam.cloud.proto.SensorMetadata sensor_metadata = 1;
inline bool AddLandmarkDataRequest::has_sensor_metadata() const {
  return this != internal_default_instance() && sensor_metadata_ != NULL;
}
inline void AddLandmarkDataRequest::clear_sensor_metadata() {
  if (GetArenaNoVirtual() == NULL && sensor_metadata_ != NULL) delete sensor_metadata_;
  sensor_metadata_ = NULL;
}
inline const ::ist_slam::cloud::proto::SensorMetadata& AddLandmarkDataRequest::sensor_metadata() const {
  const ::ist_slam::cloud::proto::SensorMetadata* p = sensor_metadata_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::SensorMetadata*>(
      &::ist_slam::cloud::proto::_SensorMetadata_default_instance_);
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddLandmarkDataRequest::mutable_sensor_metadata() {
  
  if (sensor_metadata_ == NULL) {
    sensor_metadata_ = new ::ist_slam::cloud::proto::SensorMetadata;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  return sensor_metadata_;
}
inline ::ist_slam::cloud::proto::SensorMetadata* AddLandmarkDataRequest::release_sensor_metadata() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
  
  ::ist_slam::cloud::proto::SensorMetadata* temp = sensor_metadata_;
  sensor_metadata_ = NULL;
  return temp;
}
inline void AddLandmarkDataRequest::set_allocated_sensor_metadata(::ist_slam::cloud::proto::SensorMetadata* sensor_metadata) {
  delete sensor_metadata_;
  sensor_metadata_ = sensor_metadata;
  if (sensor_metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddLandmarkDataRequest.sensor_metadata)
}

// .ist_slam.sensor.proto.LandmarkData landmark_data = 2;
inline bool AddLandmarkDataRequest::has_landmark_data() const {
  return this != internal_default_instance() && landmark_data_ != NULL;
}
inline void AddLandmarkDataRequest::clear_landmark_data() {
  if (GetArenaNoVirtual() == NULL && landmark_data_ != NULL) delete landmark_data_;
  landmark_data_ = NULL;
}
inline const ::ist_slam::sensor::proto::LandmarkData& AddLandmarkDataRequest::landmark_data() const {
  const ::ist_slam::sensor::proto::LandmarkData* p = landmark_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.AddLandmarkDataRequest.landmark_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::sensor::proto::LandmarkData*>(
      &::ist_slam::sensor::proto::_LandmarkData_default_instance_);
}
inline ::ist_slam::sensor::proto::LandmarkData* AddLandmarkDataRequest::mutable_landmark_data() {
  
  if (landmark_data_ == NULL) {
    landmark_data_ = new ::ist_slam::sensor::proto::LandmarkData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.AddLandmarkDataRequest.landmark_data)
  return landmark_data_;
}
inline ::ist_slam::sensor::proto::LandmarkData* AddLandmarkDataRequest::release_landmark_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.AddLandmarkDataRequest.landmark_data)
  
  ::ist_slam::sensor::proto::LandmarkData* temp = landmark_data_;
  landmark_data_ = NULL;
  return temp;
}
inline void AddLandmarkDataRequest::set_allocated_landmark_data(::ist_slam::sensor::proto::LandmarkData* landmark_data) {
  delete landmark_data_;
  landmark_data_ = landmark_data;
  if (landmark_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.AddLandmarkDataRequest.landmark_data)
}

// -------------------------------------------------------------------

// FinishTrajectoryRequest

// int32 trajectory_id = 1;
inline void FinishTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 FinishTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.FinishTrajectoryRequest.trajectory_id)
  return trajectory_id_;
}
inline void FinishTrajectoryRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.FinishTrajectoryRequest.trajectory_id)
}

// string client_id = 2;
inline void FinishTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FinishTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
  return client_id_.GetNoArena();
}
inline void FinishTrajectoryRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
}
#if LANG_CXX11
inline void FinishTrajectoryRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
}
#endif
inline void FinishTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline void FinishTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
}
inline ::std::string* FinishTrajectoryRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishTrajectoryRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.FinishTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// DeleteTrajectoryRequest

// int32 trajectory_id = 1;
inline void DeleteTrajectoryRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 DeleteTrajectoryRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.DeleteTrajectoryRequest.trajectory_id)
  return trajectory_id_;
}
inline void DeleteTrajectoryRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.DeleteTrajectoryRequest.trajectory_id)
}

// string client_id = 2;
inline void DeleteTrajectoryRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteTrajectoryRequest::client_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
  return client_id_.GetNoArena();
}
inline void DeleteTrajectoryRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
}
#if LANG_CXX11
inline void DeleteTrajectoryRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
}
#endif
inline void DeleteTrajectoryRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline void DeleteTrajectoryRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
}
inline ::std::string* DeleteTrajectoryRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteTrajectoryRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteTrajectoryRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.DeleteTrajectoryRequest.client_id)
}

// -------------------------------------------------------------------

// ReceiveLocalSlamResultsRequest

// int32 trajectory_id = 1;
inline void ReceiveLocalSlamResultsRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 ReceiveLocalSlamResultsRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.ReceiveLocalSlamResultsRequest.trajectory_id)
  return trajectory_id_;
}
inline void ReceiveLocalSlamResultsRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.ReceiveLocalSlamResultsRequest.trajectory_id)
}

// -------------------------------------------------------------------

// LocalSlamInsertionResult

// .ist_slam.mapping.proto.NodeId node_id = 1;
inline bool LocalSlamInsertionResult::has_node_id() const {
  return this != internal_default_instance() && node_id_ != NULL;
}
inline void LocalSlamInsertionResult::clear_node_id() {
  if (GetArenaNoVirtual() == NULL && node_id_ != NULL) delete node_id_;
  node_id_ = NULL;
}
inline const ::ist_slam::mapping::proto::NodeId& LocalSlamInsertionResult::node_id() const {
  const ::ist_slam::mapping::proto::NodeId* p = node_id_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LocalSlamInsertionResult.node_id)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::NodeId*>(
      &::ist_slam::mapping::proto::_NodeId_default_instance_);
}
inline ::ist_slam::mapping::proto::NodeId* LocalSlamInsertionResult::mutable_node_id() {
  
  if (node_id_ == NULL) {
    node_id_ = new ::ist_slam::mapping::proto::NodeId;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LocalSlamInsertionResult.node_id)
  return node_id_;
}
inline ::ist_slam::mapping::proto::NodeId* LocalSlamInsertionResult::release_node_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LocalSlamInsertionResult.node_id)
  
  ::ist_slam::mapping::proto::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void LocalSlamInsertionResult::set_allocated_node_id(::ist_slam::mapping::proto::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LocalSlamInsertionResult.node_id)
}

// -------------------------------------------------------------------

// ReceiveLocalSlamResultsResponse

// int32 trajectory_id = 1;
inline void ReceiveLocalSlamResultsResponse::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 ReceiveLocalSlamResultsResponse::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.trajectory_id)
  return trajectory_id_;
}
inline void ReceiveLocalSlamResultsResponse::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.trajectory_id)
}

// int64 timestamp = 2;
inline void ReceiveLocalSlamResultsResponse::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReceiveLocalSlamResultsResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.timestamp)
  return timestamp_;
}
inline void ReceiveLocalSlamResultsResponse::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.timestamp)
}

// .ist_slam.transform.proto.Rigid3d local_pose = 3;
inline bool ReceiveLocalSlamResultsResponse::has_local_pose() const {
  return this != internal_default_instance() && local_pose_ != NULL;
}
inline void ReceiveLocalSlamResultsResponse::clear_local_pose() {
  if (GetArenaNoVirtual() == NULL && local_pose_ != NULL) delete local_pose_;
  local_pose_ = NULL;
}
inline const ::ist_slam::transform::proto::Rigid3d& ReceiveLocalSlamResultsResponse::local_pose() const {
  const ::ist_slam::transform::proto::Rigid3d* p = local_pose_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Rigid3d*>(
      &::ist_slam::transform::proto::_Rigid3d_default_instance_);
}
inline ::ist_slam::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::mutable_local_pose() {
  
  if (local_pose_ == NULL) {
    local_pose_ = new ::ist_slam::transform::proto::Rigid3d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  return local_pose_;
}
inline ::ist_slam::transform::proto::Rigid3d* ReceiveLocalSlamResultsResponse::release_local_pose() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
  
  ::ist_slam::transform::proto::Rigid3d* temp = local_pose_;
  local_pose_ = NULL;
  return temp;
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_local_pose(::ist_slam::transform::proto::Rigid3d* local_pose) {
  delete local_pose_;
  local_pose_ = local_pose;
  if (local_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.local_pose)
}

// .ist_slam.sensor.proto.RangeData range_data = 4;
inline bool ReceiveLocalSlamResultsResponse::has_range_data() const {
  return this != internal_default_instance() && range_data_ != NULL;
}
inline void ReceiveLocalSlamResultsResponse::clear_range_data() {
  if (GetArenaNoVirtual() == NULL && range_data_ != NULL) delete range_data_;
  range_data_ = NULL;
}
inline const ::ist_slam::sensor::proto::RangeData& ReceiveLocalSlamResultsResponse::range_data() const {
  const ::ist_slam::sensor::proto::RangeData* p = range_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::sensor::proto::RangeData*>(
      &::ist_slam::sensor::proto::_RangeData_default_instance_);
}
inline ::ist_slam::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::mutable_range_data() {
  
  if (range_data_ == NULL) {
    range_data_ = new ::ist_slam::sensor::proto::RangeData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  return range_data_;
}
inline ::ist_slam::sensor::proto::RangeData* ReceiveLocalSlamResultsResponse::release_range_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
  
  ::ist_slam::sensor::proto::RangeData* temp = range_data_;
  range_data_ = NULL;
  return temp;
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_range_data(::ist_slam::sensor::proto::RangeData* range_data) {
  delete range_data_;
  range_data_ = range_data;
  if (range_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.range_data)
}

// .ist_slam.cloud.proto.LocalSlamInsertionResult insertion_result = 5;
inline bool ReceiveLocalSlamResultsResponse::has_insertion_result() const {
  return this != internal_default_instance() && insertion_result_ != NULL;
}
inline void ReceiveLocalSlamResultsResponse::clear_insertion_result() {
  if (GetArenaNoVirtual() == NULL && insertion_result_ != NULL) delete insertion_result_;
  insertion_result_ = NULL;
}
inline const ::ist_slam::cloud::proto::LocalSlamInsertionResult& ReceiveLocalSlamResultsResponse::insertion_result() const {
  const ::ist_slam::cloud::proto::LocalSlamInsertionResult* p = insertion_result_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::LocalSlamInsertionResult*>(
      &::ist_slam::cloud::proto::_LocalSlamInsertionResult_default_instance_);
}
inline ::ist_slam::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::mutable_insertion_result() {
  
  if (insertion_result_ == NULL) {
    insertion_result_ = new ::ist_slam::cloud::proto::LocalSlamInsertionResult;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  return insertion_result_;
}
inline ::ist_slam::cloud::proto::LocalSlamInsertionResult* ReceiveLocalSlamResultsResponse::release_insertion_result() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
  
  ::ist_slam::cloud::proto::LocalSlamInsertionResult* temp = insertion_result_;
  insertion_result_ = NULL;
  return temp;
}
inline void ReceiveLocalSlamResultsResponse::set_allocated_insertion_result(::ist_slam::cloud::proto::LocalSlamInsertionResult* insertion_result) {
  delete insertion_result_;
  insertion_result_ = insertion_result;
  if (insertion_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.ReceiveLocalSlamResultsResponse.insertion_result)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ReceiveGlobalSlamOptimizationsResponse

// map<int32, .ist_slam.mapping.proto.NodeId> last_optimized_node_ids = 1;
inline int ReceiveGlobalSlamOptimizationsResponse::last_optimized_node_ids_size() const {
  return last_optimized_node_ids_.size();
}
inline void ReceiveGlobalSlamOptimizationsResponse::clear_last_optimized_node_ids() {
  last_optimized_node_ids_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId >&
ReceiveGlobalSlamOptimizationsResponse::last_optimized_node_ids() const {
  // @@protoc_insertion_point(field_map:ist_slam.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_node_ids)
  return last_optimized_node_ids_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::NodeId >*
ReceiveGlobalSlamOptimizationsResponse::mutable_last_optimized_node_ids() {
  // @@protoc_insertion_point(field_mutable_map:ist_slam.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_node_ids)
  return last_optimized_node_ids_.MutableMap();
}

// map<int32, .ist_slam.mapping.proto.SubmapId> last_optimized_submap_ids = 2;
inline int ReceiveGlobalSlamOptimizationsResponse::last_optimized_submap_ids_size() const {
  return last_optimized_submap_ids_.size();
}
inline void ReceiveGlobalSlamOptimizationsResponse::clear_last_optimized_submap_ids() {
  last_optimized_submap_ids_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId >&
ReceiveGlobalSlamOptimizationsResponse::last_optimized_submap_ids() const {
  // @@protoc_insertion_point(field_map:ist_slam.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_submap_ids)
  return last_optimized_submap_ids_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::mapping::proto::SubmapId >*
ReceiveGlobalSlamOptimizationsResponse::mutable_last_optimized_submap_ids() {
  // @@protoc_insertion_point(field_mutable_map:ist_slam.cloud.proto.ReceiveGlobalSlamOptimizationsResponse.last_optimized_submap_ids)
  return last_optimized_submap_ids_.MutableMap();
}

// -------------------------------------------------------------------

// GetSubmapRequest

// .ist_slam.mapping.proto.SubmapId submap_id = 1;
inline bool GetSubmapRequest::has_submap_id() const {
  return this != internal_default_instance() && submap_id_ != NULL;
}
inline void GetSubmapRequest::clear_submap_id() {
  if (GetArenaNoVirtual() == NULL && submap_id_ != NULL) delete submap_id_;
  submap_id_ = NULL;
}
inline const ::ist_slam::mapping::proto::SubmapId& GetSubmapRequest::submap_id() const {
  const ::ist_slam::mapping::proto::SubmapId* p = submap_id_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetSubmapRequest.submap_id)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::SubmapId*>(
      &::ist_slam::mapping::proto::_SubmapId_default_instance_);
}
inline ::ist_slam::mapping::proto::SubmapId* GetSubmapRequest::mutable_submap_id() {
  
  if (submap_id_ == NULL) {
    submap_id_ = new ::ist_slam::mapping::proto::SubmapId;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetSubmapRequest.submap_id)
  return submap_id_;
}
inline ::ist_slam::mapping::proto::SubmapId* GetSubmapRequest::release_submap_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.GetSubmapRequest.submap_id)
  
  ::ist_slam::mapping::proto::SubmapId* temp = submap_id_;
  submap_id_ = NULL;
  return temp;
}
inline void GetSubmapRequest::set_allocated_submap_id(::ist_slam::mapping::proto::SubmapId* submap_id) {
  delete submap_id_;
  submap_id_ = submap_id;
  if (submap_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.GetSubmapRequest.submap_id)
}

// -------------------------------------------------------------------

// LoadStateRequest

// .ist_slam.mapping.proto.SerializedData serialized_data = 1;
inline bool LoadStateRequest::has_serialized_data() const {
  return state_chunk_case() == kSerializedData;
}
inline void LoadStateRequest::set_has_serialized_data() {
  _oneof_case_[0] = kSerializedData;
}
inline void LoadStateRequest::clear_serialized_data() {
  if (has_serialized_data()) {
    delete state_chunk_.serialized_data_;
    clear_has_state_chunk();
  }
}
inline  const ::ist_slam::mapping::proto::SerializedData& LoadStateRequest::serialized_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateRequest.serialized_data)
  return has_serialized_data()
      ? *state_chunk_.serialized_data_
      : ::ist_slam::mapping::proto::SerializedData::default_instance();
}
inline ::ist_slam::mapping::proto::SerializedData* LoadStateRequest::mutable_serialized_data() {
  if (!has_serialized_data()) {
    clear_state_chunk();
    set_has_serialized_data();
    state_chunk_.serialized_data_ = new ::ist_slam::mapping::proto::SerializedData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateRequest.serialized_data)
  return state_chunk_.serialized_data_;
}
inline ::ist_slam::mapping::proto::SerializedData* LoadStateRequest::release_serialized_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateRequest.serialized_data)
  if (has_serialized_data()) {
    clear_has_state_chunk();
    ::ist_slam::mapping::proto::SerializedData* temp = state_chunk_.serialized_data_;
    state_chunk_.serialized_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LoadStateRequest::set_allocated_serialized_data(::ist_slam::mapping::proto::SerializedData* serialized_data) {
  clear_state_chunk();
  if (serialized_data) {
    set_has_serialized_data();
    state_chunk_.serialized_data_ = serialized_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateRequest.serialized_data)
}

// .ist_slam.mapping.proto.SerializationHeader serialization_header = 2;
inline bool LoadStateRequest::has_serialization_header() const {
  return state_chunk_case() == kSerializationHeader;
}
inline void LoadStateRequest::set_has_serialization_header() {
  _oneof_case_[0] = kSerializationHeader;
}
inline void LoadStateRequest::clear_serialization_header() {
  if (has_serialization_header()) {
    delete state_chunk_.serialization_header_;
    clear_has_state_chunk();
  }
}
inline  const ::ist_slam::mapping::proto::SerializationHeader& LoadStateRequest::serialization_header() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateRequest.serialization_header)
  return has_serialization_header()
      ? *state_chunk_.serialization_header_
      : ::ist_slam::mapping::proto::SerializationHeader::default_instance();
}
inline ::ist_slam::mapping::proto::SerializationHeader* LoadStateRequest::mutable_serialization_header() {
  if (!has_serialization_header()) {
    clear_state_chunk();
    set_has_serialization_header();
    state_chunk_.serialization_header_ = new ::ist_slam::mapping::proto::SerializationHeader;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateRequest.serialization_header)
  return state_chunk_.serialization_header_;
}
inline ::ist_slam::mapping::proto::SerializationHeader* LoadStateRequest::release_serialization_header() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateRequest.serialization_header)
  if (has_serialization_header()) {
    clear_has_state_chunk();
    ::ist_slam::mapping::proto::SerializationHeader* temp = state_chunk_.serialization_header_;
    state_chunk_.serialization_header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LoadStateRequest::set_allocated_serialization_header(::ist_slam::mapping::proto::SerializationHeader* serialization_header) {
  clear_state_chunk();
  if (serialization_header) {
    set_has_serialization_header();
    state_chunk_.serialization_header_ = serialization_header;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateRequest.serialization_header)
}

// string client_id = 3;
inline bool LoadStateRequest::has_client_id() const {
  return state_chunk_case() == kClientId;
}
inline void LoadStateRequest::set_has_client_id() {
  _oneof_case_[0] = kClientId;
}
inline void LoadStateRequest::clear_client_id() {
  if (has_client_id()) {
    state_chunk_.client_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_state_chunk();
  }
}
inline const ::std::string& LoadStateRequest::client_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateRequest.client_id)
  if (has_client_id()) {
    return state_chunk_.client_id_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LoadStateRequest::set_client_id(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateRequest.client_id)
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateRequest.client_id)
}
#if LANG_CXX11
inline void LoadStateRequest::set_client_id(::std::string&& value) {
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateRequest.client_id)
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.LoadStateRequest.client_id)
}
#endif
inline void LoadStateRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.LoadStateRequest.client_id)
}
inline void LoadStateRequest::set_client_id(const char* value, size_t size) {
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  state_chunk_.client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.LoadStateRequest.client_id)
}
inline ::std::string* LoadStateRequest::mutable_client_id() {
  if (!has_client_id()) {
    clear_state_chunk();
    set_has_client_id();
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateRequest.client_id)
  return state_chunk_.client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadStateRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateRequest.client_id)
  if (has_client_id()) {
    clear_has_state_chunk();
    return state_chunk_.client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void LoadStateRequest::set_allocated_client_id(::std::string* client_id) {
  if (!has_client_id()) {
    state_chunk_.client_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_state_chunk();
  if (client_id != NULL) {
    set_has_client_id();
    state_chunk_.client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        client_id);
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateRequest.client_id)
}

// bool load_frozen_state = 4;
inline void LoadStateRequest::clear_load_frozen_state() {
  load_frozen_state_ = false;
}
inline bool LoadStateRequest::load_frozen_state() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateRequest.load_frozen_state)
  return load_frozen_state_;
}
inline void LoadStateRequest::set_load_frozen_state(bool value) {
  
  load_frozen_state_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateRequest.load_frozen_state)
}

inline bool LoadStateRequest::has_state_chunk() const {
  return state_chunk_case() != STATE_CHUNK_NOT_SET;
}
inline void LoadStateRequest::clear_has_state_chunk() {
  _oneof_case_[0] = STATE_CHUNK_NOT_SET;
}
inline LoadStateRequest::StateChunkCase LoadStateRequest::state_chunk_case() const {
  return LoadStateRequest::StateChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrajectoryRemapping

// map<int32, int32> serialized_trajectories_to_trajectories = 1;
inline int TrajectoryRemapping::serialized_trajectories_to_trajectories_size() const {
  return serialized_trajectories_to_trajectories_.size();
}
inline void TrajectoryRemapping::clear_serialized_trajectories_to_trajectories() {
  serialized_trajectories_to_trajectories_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >&
TrajectoryRemapping::serialized_trajectories_to_trajectories() const {
  // @@protoc_insertion_point(field_map:ist_slam.cloud.proto.TrajectoryRemapping.serialized_trajectories_to_trajectories)
  return serialized_trajectories_to_trajectories_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::google::protobuf::int32 >*
TrajectoryRemapping::mutable_serialized_trajectories_to_trajectories() {
  // @@protoc_insertion_point(field_mutable_map:ist_slam.cloud.proto.TrajectoryRemapping.serialized_trajectories_to_trajectories)
  return serialized_trajectories_to_trajectories_.MutableMap();
}

// -------------------------------------------------------------------

// LoadStateResponse

// .ist_slam.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
inline bool LoadStateResponse::has_trajectory_remapping() const {
  return this != internal_default_instance() && trajectory_remapping_ != NULL;
}
inline void LoadStateResponse::clear_trajectory_remapping() {
  if (GetArenaNoVirtual() == NULL && trajectory_remapping_ != NULL) delete trajectory_remapping_;
  trajectory_remapping_ = NULL;
}
inline const ::ist_slam::cloud::proto::TrajectoryRemapping& LoadStateResponse::trajectory_remapping() const {
  const ::ist_slam::cloud::proto::TrajectoryRemapping* p = trajectory_remapping_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateResponse.trajectory_remapping)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::TrajectoryRemapping*>(
      &::ist_slam::cloud::proto::_TrajectoryRemapping_default_instance_);
}
inline ::ist_slam::cloud::proto::TrajectoryRemapping* LoadStateResponse::mutable_trajectory_remapping() {
  
  if (trajectory_remapping_ == NULL) {
    trajectory_remapping_ = new ::ist_slam::cloud::proto::TrajectoryRemapping;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateResponse.trajectory_remapping)
  return trajectory_remapping_;
}
inline ::ist_slam::cloud::proto::TrajectoryRemapping* LoadStateResponse::release_trajectory_remapping() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateResponse.trajectory_remapping)
  
  ::ist_slam::cloud::proto::TrajectoryRemapping* temp = trajectory_remapping_;
  trajectory_remapping_ = NULL;
  return temp;
}
inline void LoadStateResponse::set_allocated_trajectory_remapping(::ist_slam::cloud::proto::TrajectoryRemapping* trajectory_remapping) {
  delete trajectory_remapping_;
  trajectory_remapping_ = trajectory_remapping;
  if (trajectory_remapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateResponse.trajectory_remapping)
}

// -------------------------------------------------------------------

// LoadStateFromFileRequest

// string file_path = 1;
inline void LoadStateFromFileRequest::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadStateFromFileRequest::file_path() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
  return file_path_.GetNoArena();
}
inline void LoadStateFromFileRequest::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
}
#if LANG_CXX11
inline void LoadStateFromFileRequest::set_file_path(::std::string&& value) {
  
  file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
}
#endif
inline void LoadStateFromFileRequest::set_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline void LoadStateFromFileRequest::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
}
inline ::std::string* LoadStateFromFileRequest::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadStateFromFileRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadStateFromFileRequest::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateFromFileRequest.file_path)
}

// string client_id = 2;
inline void LoadStateFromFileRequest::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoadStateFromFileRequest::client_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
  return client_id_.GetNoArena();
}
inline void LoadStateFromFileRequest::set_client_id(const ::std::string& value) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
}
#if LANG_CXX11
inline void LoadStateFromFileRequest::set_client_id(::std::string&& value) {
  
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
}
#endif
inline void LoadStateFromFileRequest::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline void LoadStateFromFileRequest::set_client_id(const char* value, size_t size) {
  
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
}
inline ::std::string* LoadStateFromFileRequest::mutable_client_id() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadStateFromFileRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
  
  return client_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadStateFromFileRequest::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    
  } else {
    
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateFromFileRequest.client_id)
}

// bool load_frozen_state = 3;
inline void LoadStateFromFileRequest::clear_load_frozen_state() {
  load_frozen_state_ = false;
}
inline bool LoadStateFromFileRequest::load_frozen_state() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateFromFileRequest.load_frozen_state)
  return load_frozen_state_;
}
inline void LoadStateFromFileRequest::set_load_frozen_state(bool value) {
  
  load_frozen_state_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.LoadStateFromFileRequest.load_frozen_state)
}

// -------------------------------------------------------------------

// LoadStateFromFileResponse

// .ist_slam.cloud.proto.TrajectoryRemapping trajectory_remapping = 1;
inline bool LoadStateFromFileResponse::has_trajectory_remapping() const {
  return this != internal_default_instance() && trajectory_remapping_ != NULL;
}
inline void LoadStateFromFileResponse::clear_trajectory_remapping() {
  if (GetArenaNoVirtual() == NULL && trajectory_remapping_ != NULL) delete trajectory_remapping_;
  trajectory_remapping_ = NULL;
}
inline const ::ist_slam::cloud::proto::TrajectoryRemapping& LoadStateFromFileResponse::trajectory_remapping() const {
  const ::ist_slam::cloud::proto::TrajectoryRemapping* p = trajectory_remapping_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::TrajectoryRemapping*>(
      &::ist_slam::cloud::proto::_TrajectoryRemapping_default_instance_);
}
inline ::ist_slam::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::mutable_trajectory_remapping() {
  
  if (trajectory_remapping_ == NULL) {
    trajectory_remapping_ = new ::ist_slam::cloud::proto::TrajectoryRemapping;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  return trajectory_remapping_;
}
inline ::ist_slam::cloud::proto::TrajectoryRemapping* LoadStateFromFileResponse::release_trajectory_remapping() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
  
  ::ist_slam::cloud::proto::TrajectoryRemapping* temp = trajectory_remapping_;
  trajectory_remapping_ = NULL;
  return temp;
}
inline void LoadStateFromFileResponse::set_allocated_trajectory_remapping(::ist_slam::cloud::proto::TrajectoryRemapping* trajectory_remapping) {
  delete trajectory_remapping_;
  trajectory_remapping_ = trajectory_remapping;
  if (trajectory_remapping) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.LoadStateFromFileResponse.trajectory_remapping)
}

// -------------------------------------------------------------------

// GetSubmapResponse

// .ist_slam.mapping.proto.SubmapQuery.Response submap_query_response = 1;
inline bool GetSubmapResponse::has_submap_query_response() const {
  return this != internal_default_instance() && submap_query_response_ != NULL;
}
inline void GetSubmapResponse::clear_submap_query_response() {
  if (GetArenaNoVirtual() == NULL && submap_query_response_ != NULL) delete submap_query_response_;
  submap_query_response_ = NULL;
}
inline const ::ist_slam::mapping::proto::SubmapQuery_Response& GetSubmapResponse::submap_query_response() const {
  const ::ist_slam::mapping::proto::SubmapQuery_Response* p = submap_query_response_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetSubmapResponse.submap_query_response)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::SubmapQuery_Response*>(
      &::ist_slam::mapping::proto::_SubmapQuery_Response_default_instance_);
}
inline ::ist_slam::mapping::proto::SubmapQuery_Response* GetSubmapResponse::mutable_submap_query_response() {
  
  if (submap_query_response_ == NULL) {
    submap_query_response_ = new ::ist_slam::mapping::proto::SubmapQuery_Response;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetSubmapResponse.submap_query_response)
  return submap_query_response_;
}
inline ::ist_slam::mapping::proto::SubmapQuery_Response* GetSubmapResponse::release_submap_query_response() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.GetSubmapResponse.submap_query_response)
  
  ::ist_slam::mapping::proto::SubmapQuery_Response* temp = submap_query_response_;
  submap_query_response_ = NULL;
  return temp;
}
inline void GetSubmapResponse::set_allocated_submap_query_response(::ist_slam::mapping::proto::SubmapQuery_Response* submap_query_response) {
  delete submap_query_response_;
  submap_query_response_ = submap_query_response;
  if (submap_query_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.GetSubmapResponse.submap_query_response)
}

// string error_msg = 2;
inline void GetSubmapResponse::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSubmapResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
  return error_msg_.GetNoArena();
}
inline void GetSubmapResponse::set_error_msg(const ::std::string& value) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
}
#if LANG_CXX11
inline void GetSubmapResponse::set_error_msg(::std::string&& value) {
  
  error_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
}
#endif
inline void GetSubmapResponse::set_error_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
}
inline void GetSubmapResponse::set_error_msg(const char* value, size_t size) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
}
inline ::std::string* GetSubmapResponse::mutable_error_msg() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSubmapResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
  
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSubmapResponse::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    
  } else {
    
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.GetSubmapResponse.error_msg)
}

// -------------------------------------------------------------------

// TrajectoryNodePose_ConstantPoseData

// int64 timestamp = 1;
inline void TrajectoryNodePose_ConstantPoseData::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrajectoryNodePose_ConstantPoseData::timestamp() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData.timestamp)
  return timestamp_;
}
inline void TrajectoryNodePose_ConstantPoseData::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData.timestamp)
}

// .ist_slam.transform.proto.Rigid3d local_pose = 2;
inline bool TrajectoryNodePose_ConstantPoseData::has_local_pose() const {
  return this != internal_default_instance() && local_pose_ != NULL;
}
inline void TrajectoryNodePose_ConstantPoseData::clear_local_pose() {
  if (GetArenaNoVirtual() == NULL && local_pose_ != NULL) delete local_pose_;
  local_pose_ = NULL;
}
inline const ::ist_slam::transform::proto::Rigid3d& TrajectoryNodePose_ConstantPoseData::local_pose() const {
  const ::ist_slam::transform::proto::Rigid3d* p = local_pose_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Rigid3d*>(
      &::ist_slam::transform::proto::_Rigid3d_default_instance_);
}
inline ::ist_slam::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::mutable_local_pose() {
  
  if (local_pose_ == NULL) {
    local_pose_ = new ::ist_slam::transform::proto::Rigid3d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  return local_pose_;
}
inline ::ist_slam::transform::proto::Rigid3d* TrajectoryNodePose_ConstantPoseData::release_local_pose() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
  
  ::ist_slam::transform::proto::Rigid3d* temp = local_pose_;
  local_pose_ = NULL;
  return temp;
}
inline void TrajectoryNodePose_ConstantPoseData::set_allocated_local_pose(::ist_slam::transform::proto::Rigid3d* local_pose) {
  delete local_pose_;
  local_pose_ = local_pose;
  if (local_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData.local_pose)
}

// -------------------------------------------------------------------

// TrajectoryNodePose

// .ist_slam.mapping.proto.NodeId node_id = 1;
inline bool TrajectoryNodePose::has_node_id() const {
  return this != internal_default_instance() && node_id_ != NULL;
}
inline void TrajectoryNodePose::clear_node_id() {
  if (GetArenaNoVirtual() == NULL && node_id_ != NULL) delete node_id_;
  node_id_ = NULL;
}
inline const ::ist_slam::mapping::proto::NodeId& TrajectoryNodePose::node_id() const {
  const ::ist_slam::mapping::proto::NodeId* p = node_id_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.TrajectoryNodePose.node_id)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::NodeId*>(
      &::ist_slam::mapping::proto::_NodeId_default_instance_);
}
inline ::ist_slam::mapping::proto::NodeId* TrajectoryNodePose::mutable_node_id() {
  
  if (node_id_ == NULL) {
    node_id_ = new ::ist_slam::mapping::proto::NodeId;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.TrajectoryNodePose.node_id)
  return node_id_;
}
inline ::ist_slam::mapping::proto::NodeId* TrajectoryNodePose::release_node_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.TrajectoryNodePose.node_id)
  
  ::ist_slam::mapping::proto::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void TrajectoryNodePose::set_allocated_node_id(::ist_slam::mapping::proto::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.TrajectoryNodePose.node_id)
}

// .ist_slam.transform.proto.Rigid3d global_pose = 2;
inline bool TrajectoryNodePose::has_global_pose() const {
  return this != internal_default_instance() && global_pose_ != NULL;
}
inline void TrajectoryNodePose::clear_global_pose() {
  if (GetArenaNoVirtual() == NULL && global_pose_ != NULL) delete global_pose_;
  global_pose_ = NULL;
}
inline const ::ist_slam::transform::proto::Rigid3d& TrajectoryNodePose::global_pose() const {
  const ::ist_slam::transform::proto::Rigid3d* p = global_pose_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.TrajectoryNodePose.global_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Rigid3d*>(
      &::ist_slam::transform::proto::_Rigid3d_default_instance_);
}
inline ::ist_slam::transform::proto::Rigid3d* TrajectoryNodePose::mutable_global_pose() {
  
  if (global_pose_ == NULL) {
    global_pose_ = new ::ist_slam::transform::proto::Rigid3d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.TrajectoryNodePose.global_pose)
  return global_pose_;
}
inline ::ist_slam::transform::proto::Rigid3d* TrajectoryNodePose::release_global_pose() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.TrajectoryNodePose.global_pose)
  
  ::ist_slam::transform::proto::Rigid3d* temp = global_pose_;
  global_pose_ = NULL;
  return temp;
}
inline void TrajectoryNodePose::set_allocated_global_pose(::ist_slam::transform::proto::Rigid3d* global_pose) {
  delete global_pose_;
  global_pose_ = global_pose;
  if (global_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.TrajectoryNodePose.global_pose)
}

// .ist_slam.cloud.proto.TrajectoryNodePose.ConstantPoseData constant_pose_data = 3;
inline bool TrajectoryNodePose::has_constant_pose_data() const {
  return this != internal_default_instance() && constant_pose_data_ != NULL;
}
inline void TrajectoryNodePose::clear_constant_pose_data() {
  if (GetArenaNoVirtual() == NULL && constant_pose_data_ != NULL) delete constant_pose_data_;
  constant_pose_data_ = NULL;
}
inline const ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData& TrajectoryNodePose::constant_pose_data() const {
  const ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* p = constant_pose_data_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.TrajectoryNodePose.constant_pose_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData*>(
      &::ist_slam::cloud::proto::_TrajectoryNodePose_ConstantPoseData_default_instance_);
}
inline ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::mutable_constant_pose_data() {
  
  if (constant_pose_data_ == NULL) {
    constant_pose_data_ = new ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.TrajectoryNodePose.constant_pose_data)
  return constant_pose_data_;
}
inline ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* TrajectoryNodePose::release_constant_pose_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.TrajectoryNodePose.constant_pose_data)
  
  ::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* temp = constant_pose_data_;
  constant_pose_data_ = NULL;
  return temp;
}
inline void TrajectoryNodePose::set_allocated_constant_pose_data(::ist_slam::cloud::proto::TrajectoryNodePose_ConstantPoseData* constant_pose_data) {
  delete constant_pose_data_;
  constant_pose_data_ = constant_pose_data;
  if (constant_pose_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.TrajectoryNodePose.constant_pose_data)
}

// -------------------------------------------------------------------

// GetTrajectoryNodePosesResponse

// repeated .ist_slam.cloud.proto.TrajectoryNodePose node_poses = 1;
inline int GetTrajectoryNodePosesResponse::node_poses_size() const {
  return node_poses_.size();
}
inline void GetTrajectoryNodePosesResponse::clear_node_poses() {
  node_poses_.Clear();
}
inline const ::ist_slam::cloud::proto::TrajectoryNodePose& GetTrajectoryNodePosesResponse::node_poses(int index) const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Get(index);
}
inline ::ist_slam::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::mutable_node_poses(int index) {
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Mutable(index);
}
inline ::ist_slam::cloud::proto::TrajectoryNodePose* GetTrajectoryNodePosesResponse::add_node_poses() {
  // @@protoc_insertion_point(field_add:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::TrajectoryNodePose >*
GetTrajectoryNodePosesResponse::mutable_node_poses() {
  // @@protoc_insertion_point(field_mutable_list:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return &node_poses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::TrajectoryNodePose >&
GetTrajectoryNodePosesResponse::node_poses() const {
  // @@protoc_insertion_point(field_list:ist_slam.cloud.proto.GetTrajectoryNodePosesResponse.node_poses)
  return node_poses_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetTrajectoryStatesResponse

// map<int32, .ist_slam.cloud.proto.TrajectoryState> trajectories_state = 1;
inline int GetTrajectoryStatesResponse::trajectories_state_size() const {
  return trajectories_state_.size();
}
inline void GetTrajectoryStatesResponse::clear_trajectories_state() {
  trajectories_state_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState >&
GetTrajectoryStatesResponse::trajectories_state() const {
  // @@protoc_insertion_point(field_map:ist_slam.cloud.proto.GetTrajectoryStatesResponse.trajectories_state)
  return trajectories_state_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::ist_slam::cloud::proto::TrajectoryState >*
GetTrajectoryStatesResponse::mutable_trajectories_state() {
  // @@protoc_insertion_point(field_mutable_map:ist_slam.cloud.proto.GetTrajectoryStatesResponse.trajectories_state)
  return trajectories_state_.MutableMap();
}

// -------------------------------------------------------------------

// GetLandmarkPosesResponse

// repeated .ist_slam.mapping.proto.PoseGraph.LandmarkPose landmark_poses = 1;
inline int GetLandmarkPosesResponse::landmark_poses_size() const {
  return landmark_poses_.size();
}
inline void GetLandmarkPosesResponse::clear_landmark_poses() {
  landmark_poses_.Clear();
}
inline const ::ist_slam::mapping::proto::PoseGraph_LandmarkPose& GetLandmarkPosesResponse::landmark_poses(int index) const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Get(index);
}
inline ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::mutable_landmark_poses(int index) {
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Mutable(index);
}
inline ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* GetLandmarkPosesResponse::add_landmark_poses() {
  // @@protoc_insertion_point(field_add:ist_slam.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_LandmarkPose >*
GetLandmarkPosesResponse::mutable_landmark_poses() {
  // @@protoc_insertion_point(field_mutable_list:ist_slam.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return &landmark_poses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_LandmarkPose >&
GetLandmarkPosesResponse::landmark_poses() const {
  // @@protoc_insertion_point(field_list:ist_slam.cloud.proto.GetLandmarkPosesResponse.landmark_poses)
  return landmark_poses_;
}

// -------------------------------------------------------------------

// SetLandmarkPoseRequest

// .ist_slam.mapping.proto.PoseGraph.LandmarkPose landmark_pose = 1;
inline bool SetLandmarkPoseRequest::has_landmark_pose() const {
  return this != internal_default_instance() && landmark_pose_ != NULL;
}
inline void SetLandmarkPoseRequest::clear_landmark_pose() {
  if (GetArenaNoVirtual() == NULL && landmark_pose_ != NULL) delete landmark_pose_;
  landmark_pose_ = NULL;
}
inline const ::ist_slam::mapping::proto::PoseGraph_LandmarkPose& SetLandmarkPoseRequest::landmark_pose() const {
  const ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* p = landmark_pose_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::PoseGraph_LandmarkPose*>(
      &::ist_slam::mapping::proto::_PoseGraph_LandmarkPose_default_instance_);
}
inline ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::mutable_landmark_pose() {
  
  if (landmark_pose_ == NULL) {
    landmark_pose_ = new ::ist_slam::mapping::proto::PoseGraph_LandmarkPose;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  return landmark_pose_;
}
inline ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* SetLandmarkPoseRequest::release_landmark_pose() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
  
  ::ist_slam::mapping::proto::PoseGraph_LandmarkPose* temp = landmark_pose_;
  landmark_pose_ = NULL;
  return temp;
}
inline void SetLandmarkPoseRequest::set_allocated_landmark_pose(::ist_slam::mapping::proto::PoseGraph_LandmarkPose* landmark_pose) {
  delete landmark_pose_;
  landmark_pose_ = landmark_pose;
  if (landmark_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SetLandmarkPoseRequest.landmark_pose)
}

// -------------------------------------------------------------------

// SubmapPose

// .ist_slam.mapping.proto.SubmapId submap_id = 1;
inline bool SubmapPose::has_submap_id() const {
  return this != internal_default_instance() && submap_id_ != NULL;
}
inline void SubmapPose::clear_submap_id() {
  if (GetArenaNoVirtual() == NULL && submap_id_ != NULL) delete submap_id_;
  submap_id_ = NULL;
}
inline const ::ist_slam::mapping::proto::SubmapId& SubmapPose::submap_id() const {
  const ::ist_slam::mapping::proto::SubmapId* p = submap_id_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SubmapPose.submap_id)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::mapping::proto::SubmapId*>(
      &::ist_slam::mapping::proto::_SubmapId_default_instance_);
}
inline ::ist_slam::mapping::proto::SubmapId* SubmapPose::mutable_submap_id() {
  
  if (submap_id_ == NULL) {
    submap_id_ = new ::ist_slam::mapping::proto::SubmapId;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SubmapPose.submap_id)
  return submap_id_;
}
inline ::ist_slam::mapping::proto::SubmapId* SubmapPose::release_submap_id() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SubmapPose.submap_id)
  
  ::ist_slam::mapping::proto::SubmapId* temp = submap_id_;
  submap_id_ = NULL;
  return temp;
}
inline void SubmapPose::set_allocated_submap_id(::ist_slam::mapping::proto::SubmapId* submap_id) {
  delete submap_id_;
  submap_id_ = submap_id;
  if (submap_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SubmapPose.submap_id)
}

// int32 submap_version = 2;
inline void SubmapPose::clear_submap_version() {
  submap_version_ = 0;
}
inline ::google::protobuf::int32 SubmapPose::submap_version() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SubmapPose.submap_version)
  return submap_version_;
}
inline void SubmapPose::set_submap_version(::google::protobuf::int32 value) {
  
  submap_version_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.SubmapPose.submap_version)
}

// .ist_slam.transform.proto.Rigid3d global_pose = 3;
inline bool SubmapPose::has_global_pose() const {
  return this != internal_default_instance() && global_pose_ != NULL;
}
inline void SubmapPose::clear_global_pose() {
  if (GetArenaNoVirtual() == NULL && global_pose_ != NULL) delete global_pose_;
  global_pose_ = NULL;
}
inline const ::ist_slam::transform::proto::Rigid3d& SubmapPose::global_pose() const {
  const ::ist_slam::transform::proto::Rigid3d* p = global_pose_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.SubmapPose.global_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Rigid3d*>(
      &::ist_slam::transform::proto::_Rigid3d_default_instance_);
}
inline ::ist_slam::transform::proto::Rigid3d* SubmapPose::mutable_global_pose() {
  
  if (global_pose_ == NULL) {
    global_pose_ = new ::ist_slam::transform::proto::Rigid3d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.SubmapPose.global_pose)
  return global_pose_;
}
inline ::ist_slam::transform::proto::Rigid3d* SubmapPose::release_global_pose() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.SubmapPose.global_pose)
  
  ::ist_slam::transform::proto::Rigid3d* temp = global_pose_;
  global_pose_ = NULL;
  return temp;
}
inline void SubmapPose::set_allocated_global_pose(::ist_slam::transform::proto::Rigid3d* global_pose) {
  delete global_pose_;
  global_pose_ = global_pose;
  if (global_pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.SubmapPose.global_pose)
}

// -------------------------------------------------------------------

// GetAllSubmapPosesResponse

// repeated .ist_slam.cloud.proto.SubmapPose submap_poses = 1;
inline int GetAllSubmapPosesResponse::submap_poses_size() const {
  return submap_poses_.size();
}
inline void GetAllSubmapPosesResponse::clear_submap_poses() {
  submap_poses_.Clear();
}
inline const ::ist_slam::cloud::proto::SubmapPose& GetAllSubmapPosesResponse::submap_poses(int index) const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Get(index);
}
inline ::ist_slam::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::mutable_submap_poses(int index) {
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Mutable(index);
}
inline ::ist_slam::cloud::proto::SubmapPose* GetAllSubmapPosesResponse::add_submap_poses() {
  // @@protoc_insertion_point(field_add:ist_slam.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SubmapPose >*
GetAllSubmapPosesResponse::mutable_submap_poses() {
  // @@protoc_insertion_point(field_mutable_list:ist_slam.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return &submap_poses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ist_slam::cloud::proto::SubmapPose >&
GetAllSubmapPosesResponse::submap_poses() const {
  // @@protoc_insertion_point(field_list:ist_slam.cloud.proto.GetAllSubmapPosesResponse.submap_poses)
  return submap_poses_;
}

// -------------------------------------------------------------------

// GetLocalToGlobalTransformRequest

// int32 trajectory_id = 1;
inline void GetLocalToGlobalTransformRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 GetLocalToGlobalTransformRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetLocalToGlobalTransformRequest.trajectory_id)
  return trajectory_id_;
}
inline void GetLocalToGlobalTransformRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.GetLocalToGlobalTransformRequest.trajectory_id)
}

// -------------------------------------------------------------------

// GetLocalToGlobalTransformResponse

// .ist_slam.transform.proto.Rigid3d local_to_global = 1;
inline bool GetLocalToGlobalTransformResponse::has_local_to_global() const {
  return this != internal_default_instance() && local_to_global_ != NULL;
}
inline void GetLocalToGlobalTransformResponse::clear_local_to_global() {
  if (GetArenaNoVirtual() == NULL && local_to_global_ != NULL) delete local_to_global_;
  local_to_global_ = NULL;
}
inline const ::ist_slam::transform::proto::Rigid3d& GetLocalToGlobalTransformResponse::local_to_global() const {
  const ::ist_slam::transform::proto::Rigid3d* p = local_to_global_;
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  return p != NULL ? *p : *reinterpret_cast<const ::ist_slam::transform::proto::Rigid3d*>(
      &::ist_slam::transform::proto::_Rigid3d_default_instance_);
}
inline ::ist_slam::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::mutable_local_to_global() {
  
  if (local_to_global_ == NULL) {
    local_to_global_ = new ::ist_slam::transform::proto::Rigid3d;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  return local_to_global_;
}
inline ::ist_slam::transform::proto::Rigid3d* GetLocalToGlobalTransformResponse::release_local_to_global() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
  
  ::ist_slam::transform::proto::Rigid3d* temp = local_to_global_;
  local_to_global_ = NULL;
  return temp;
}
inline void GetLocalToGlobalTransformResponse::set_allocated_local_to_global(::ist_slam::transform::proto::Rigid3d* local_to_global) {
  delete local_to_global_;
  local_to_global_ = local_to_global;
  if (local_to_global) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.GetLocalToGlobalTransformResponse.local_to_global)
}

// -------------------------------------------------------------------

// GetConstraintsResponse

// repeated .ist_slam.mapping.proto.PoseGraph.Constraint constraints = 1;
inline int GetConstraintsResponse::constraints_size() const {
  return constraints_.size();
}
inline void GetConstraintsResponse::clear_constraints() {
  constraints_.Clear();
}
inline const ::ist_slam::mapping::proto::PoseGraph_Constraint& GetConstraintsResponse::constraints(int index) const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Get(index);
}
inline ::ist_slam::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::mutable_constraints(int index) {
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Mutable(index);
}
inline ::ist_slam::mapping::proto::PoseGraph_Constraint* GetConstraintsResponse::add_constraints() {
  // @@protoc_insertion_point(field_add:ist_slam.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_Constraint >*
GetConstraintsResponse::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:ist_slam.cloud.proto.GetConstraintsResponse.constraints)
  return &constraints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ist_slam::mapping::proto::PoseGraph_Constraint >&
GetConstraintsResponse::constraints() const {
  // @@protoc_insertion_point(field_list:ist_slam.cloud.proto.GetConstraintsResponse.constraints)
  return constraints_;
}

// -------------------------------------------------------------------

// WriteStateResponse

// .ist_slam.mapping.proto.SerializationHeader header = 1;
inline bool WriteStateResponse::has_header() const {
  return state_chunk_case() == kHeader;
}
inline void WriteStateResponse::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline void WriteStateResponse::clear_header() {
  if (has_header()) {
    delete state_chunk_.header_;
    clear_has_state_chunk();
  }
}
inline  const ::ist_slam::mapping::proto::SerializationHeader& WriteStateResponse::header() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.WriteStateResponse.header)
  return has_header()
      ? *state_chunk_.header_
      : ::ist_slam::mapping::proto::SerializationHeader::default_instance();
}
inline ::ist_slam::mapping::proto::SerializationHeader* WriteStateResponse::mutable_header() {
  if (!has_header()) {
    clear_state_chunk();
    set_has_header();
    state_chunk_.header_ = new ::ist_slam::mapping::proto::SerializationHeader;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.WriteStateResponse.header)
  return state_chunk_.header_;
}
inline ::ist_slam::mapping::proto::SerializationHeader* WriteStateResponse::release_header() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.WriteStateResponse.header)
  if (has_header()) {
    clear_has_state_chunk();
    ::ist_slam::mapping::proto::SerializationHeader* temp = state_chunk_.header_;
    state_chunk_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void WriteStateResponse::set_allocated_header(::ist_slam::mapping::proto::SerializationHeader* header) {
  clear_state_chunk();
  if (header) {
    set_has_header();
    state_chunk_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.WriteStateResponse.header)
}

// .ist_slam.mapping.proto.SerializedData serialized_data = 2;
inline bool WriteStateResponse::has_serialized_data() const {
  return state_chunk_case() == kSerializedData;
}
inline void WriteStateResponse::set_has_serialized_data() {
  _oneof_case_[0] = kSerializedData;
}
inline void WriteStateResponse::clear_serialized_data() {
  if (has_serialized_data()) {
    delete state_chunk_.serialized_data_;
    clear_has_state_chunk();
  }
}
inline  const ::ist_slam::mapping::proto::SerializedData& WriteStateResponse::serialized_data() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.WriteStateResponse.serialized_data)
  return has_serialized_data()
      ? *state_chunk_.serialized_data_
      : ::ist_slam::mapping::proto::SerializedData::default_instance();
}
inline ::ist_slam::mapping::proto::SerializedData* WriteStateResponse::mutable_serialized_data() {
  if (!has_serialized_data()) {
    clear_state_chunk();
    set_has_serialized_data();
    state_chunk_.serialized_data_ = new ::ist_slam::mapping::proto::SerializedData;
  }
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.WriteStateResponse.serialized_data)
  return state_chunk_.serialized_data_;
}
inline ::ist_slam::mapping::proto::SerializedData* WriteStateResponse::release_serialized_data() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.WriteStateResponse.serialized_data)
  if (has_serialized_data()) {
    clear_has_state_chunk();
    ::ist_slam::mapping::proto::SerializedData* temp = state_chunk_.serialized_data_;
    state_chunk_.serialized_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void WriteStateResponse::set_allocated_serialized_data(::ist_slam::mapping::proto::SerializedData* serialized_data) {
  clear_state_chunk();
  if (serialized_data) {
    set_has_serialized_data();
    state_chunk_.serialized_data_ = serialized_data;
  }
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.WriteStateResponse.serialized_data)
}

inline bool WriteStateResponse::has_state_chunk() const {
  return state_chunk_case() != STATE_CHUNK_NOT_SET;
}
inline void WriteStateResponse::clear_has_state_chunk() {
  _oneof_case_[0] = STATE_CHUNK_NOT_SET;
}
inline WriteStateResponse::StateChunkCase WriteStateResponse::state_chunk_case() const {
  return WriteStateResponse::StateChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteStateToFileRequest

// string filename = 1;
inline void WriteStateToFileRequest::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteStateToFileRequest::filename() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
  return filename_.GetNoArena();
}
inline void WriteStateToFileRequest::set_filename(const ::std::string& value) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
}
#if LANG_CXX11
inline void WriteStateToFileRequest::set_filename(::std::string&& value) {
  
  filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
}
#endif
inline void WriteStateToFileRequest::set_filename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
}
inline void WriteStateToFileRequest::set_filename(const char* value, size_t size) {
  
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
}
inline ::std::string* WriteStateToFileRequest::mutable_filename() {
  
  // @@protoc_insertion_point(field_mutable:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteStateToFileRequest::release_filename() {
  // @@protoc_insertion_point(field_release:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
  
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteStateToFileRequest::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    
  } else {
    
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:ist_slam.cloud.proto.WriteStateToFileRequest.filename)
}

// -------------------------------------------------------------------

// WriteStateToFileResponse

// bool success = 1;
inline void WriteStateToFileResponse::clear_success() {
  success_ = false;
}
inline bool WriteStateToFileResponse::success() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.WriteStateToFileResponse.success)
  return success_;
}
inline void WriteStateToFileResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.WriteStateToFileResponse.success)
}

// -------------------------------------------------------------------

// IsTrajectoryFinishedRequest

// int32 trajectory_id = 1;
inline void IsTrajectoryFinishedRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 IsTrajectoryFinishedRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.IsTrajectoryFinishedRequest.trajectory_id)
  return trajectory_id_;
}
inline void IsTrajectoryFinishedRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.IsTrajectoryFinishedRequest.trajectory_id)
}

// -------------------------------------------------------------------

// IsTrajectoryFinishedResponse

// bool is_finished = 1;
inline void IsTrajectoryFinishedResponse::clear_is_finished() {
  is_finished_ = false;
}
inline bool IsTrajectoryFinishedResponse::is_finished() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.IsTrajectoryFinishedResponse.is_finished)
  return is_finished_;
}
inline void IsTrajectoryFinishedResponse::set_is_finished(bool value) {
  
  is_finished_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.IsTrajectoryFinishedResponse.is_finished)
}

// -------------------------------------------------------------------

// IsTrajectoryFrozenRequest

// int32 trajectory_id = 1;
inline void IsTrajectoryFrozenRequest::clear_trajectory_id() {
  trajectory_id_ = 0;
}
inline ::google::protobuf::int32 IsTrajectoryFrozenRequest::trajectory_id() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.IsTrajectoryFrozenRequest.trajectory_id)
  return trajectory_id_;
}
inline void IsTrajectoryFrozenRequest::set_trajectory_id(::google::protobuf::int32 value) {
  
  trajectory_id_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.IsTrajectoryFrozenRequest.trajectory_id)
}

// -------------------------------------------------------------------

// IsTrajectoryFrozenResponse

// bool is_frozen = 1;
inline void IsTrajectoryFrozenResponse::clear_is_frozen() {
  is_frozen_ = false;
}
inline bool IsTrajectoryFrozenResponse::is_frozen() const {
  // @@protoc_insertion_point(field_get:ist_slam.cloud.proto.IsTrajectoryFrozenResponse.is_frozen)
  return is_frozen_;
}
inline void IsTrajectoryFrozenResponse::set_is_frozen(bool value) {
  
  is_frozen_ = value;
  // @@protoc_insertion_point(field_set:ist_slam.cloud.proto.IsTrajectoryFrozenResponse.is_frozen)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto
}  // namespace cloud
}  // namespace ist_slam

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ist_slam::cloud::proto::SensorType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ist_slam::cloud::proto::SensorType>() {
  return ::ist_slam::cloud::proto::SensorType_descriptor();
}
template <> struct is_proto_enum< ::ist_slam::cloud::proto::TrajectoryState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ist_slam::cloud::proto::TrajectoryState>() {
  return ::ist_slam::cloud::proto::TrajectoryState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ist_5fslam_2fcloud_2fproto_2fmap_5fbuilder_5fservice_2eproto__INCLUDED
